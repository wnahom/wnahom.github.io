<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="mohan">





<title>algorithm | nahom&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">nahom&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">nahom&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">algorithm</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">mohan</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 8, 2025&nbsp;&nbsp;13:37:11</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="算法学习笔记"><a href="#算法学习笔记" class="headerlink" title="算法学习笔记"></a>算法学习笔记</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>此笔记大致按照<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/introduction/11/">AcWing - 算法基础课</a>顺序整理，各算法中的链接绝大部分为我真实在b站学完的网课，还包含部分CSDN和OI维基百科中的内容，希望对你有所帮助。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_80215560/article/details/136604635?sharetype=blog&shareId=136604635&sharerefer=APP&sharesource=2401_87034440&sharefrom=link">https://blog.csdn.net/2301_80215560/article/details/136604635?sharetype=blog&amp;shareId=136604635&amp;sharerefer=APP&amp;sharesource=2401_87034440&amp;sharefrom=link</a></p>
<p><strong>左程云</strong>   <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/algorithmzuo/algorithm-journey">https://github.com/algorithmzuo/algorithm-journey</a></p>
<p><strong>004 021 023 025 028 029</strong></p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>相邻两个元素的值进行两两比较，若发现前一个数大于后一个数则交换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>;<span class="comment">//不能是n，不然会越界</span></span><br><span class="line">	<span class="keyword">while</span>(end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">bool</span> exchange = <span class="literal">false</span>;<span class="comment">//优化，比较之后没有交换，说明已经排好了，就break循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">swap</span>(&amp;a[i], &amp;a[i + <span class="number">1</span>]);<span class="comment">//交换</span></span><br><span class="line">				exchange++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (exchange == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>左程云021、022</strong>  <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>拆分原数组，分别排序，再 merge 归并。归并排序是一种稳定的排序算法，时间复杂度为 <em>O</em>(<em>n</em>log<em>n</em>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(m - l + <span class="number">1</span>)</span>, <span class="title">R</span><span class="params">(r - m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.<span class="built_in">size</span>(); ++i) L[i] = nums[l + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; R.<span class="built_in">size</span>(); ++j) R[j] = nums[m + <span class="number">1</span> + j];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L.<span class="built_in">size</span>() &amp;&amp; j &lt; R.<span class="built_in">size</span>())</span><br><span class="line">        nums[k++] = L[i] &lt;= R[j] ? L[i++] : R[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L.<span class="built_in">size</span>()) nums[k++] = L[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; R.<span class="built_in">size</span>()) nums[k++] = R[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, l, m);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">merge</span>(nums, l, m, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="桶排序、基数排序、计数排序"><a href="#桶排序、基数排序、计数排序" class="headerlink" title="桶排序、基数排序、计数排序"></a>桶排序、基数排序、计数排序</h4><p><strong>左程云028</strong></p>
<p>这三种排序算法都不基于比较，对数据特征有要求。计数排序适用于已知数值范围的场景；基数排序通常要求处理十进制非负整数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">思路：大问题化小</span><br><span class="line">桶排序(Bucket sort)或所谓的箱排序，是一种分块的排序算法，工作的原理是将数组分到有限数量的桶里，</span><br><span class="line">每个桶的大小都相等。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</span><br><span class="line">把待排序序列（数组）中的数据根据函数映射方法分配到若干个桶中，</span><br><span class="line">在分别对各个桶进行排序，最后依次按顺序取出桶中的数据。</span><br><span class="line">适用于数据分配均匀，数据比较大，相对集中的情况。</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">double</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">buckets</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> num : arr) &#123;</span><br><span class="line">        <span class="type">int</span> idx = n * num;</span><br><span class="line">        buckets[idx].<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; bucket : buckets) <span class="built_in">sort</span>(bucket.<span class="built_in">begin</span>(), bucket.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; bucket : buckets)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> num : bucket) arr[idx++] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序 一种特殊的排序，没有比较</span></span><br><span class="line">例（仅有<span class="number">0</span><span class="number">-10</span>）</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">以数组的下标当做数值，有这个数的时候a[i]++; </span><br><span class="line">局限：适用于整数。数要求集中（否则空间的浪费大）</span><br></pre></td></tr></table></figure>



<h4 id="基数排序-一般要求为十进制非负整数"><a href="#基数排序-一般要求为十进制非负整数" class="headerlink" title="基数排序(一般要求为十进制非负整数)"></a>基数排序(一般要求为十进制非负整数)</h4><p><strong>左程云028</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Lh4y1c7Aw?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Lh4y1c7Aw?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>判断最大的位数是几位，对每一位进行桶排序。</p>
<p>从个位开始，数组按个位数字大小入桶，然后从0-9倒出，此后十位百位同上循环，最终结果即有序。从低位开始作用为保留低位大小关系。</p>
<p><strong>技巧1 前缀分区做桶排列</strong></p>
<p>统计每个数字出现次数后做前缀和得到数组(x)，则从右向左遍历原数组时，该数字在保留相对次序情况下应该出现在x数组对应的数字-1的位置，做完此操作后x数组对应数字–。</p>
<p>故该技巧可以用于基数排序时对每一位数字进行排序任务。</p>
<p><strong>技巧2 怎么得到每一位</strong></p>
<p>用一个变量offset初始化为1，所求数字n。(n&#x2F;offset)%10该位数操作玩后offset*&#x3D;10依次得到每一位数字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">最终code</span><br><span class="line">    <span class="comment">// 理解的时候可以假设BASE = 10</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> offset = <span class="number">1</span>; bits &gt; <span class="number">0</span>; offset *= BASE, bits--) &#123;</span><br><span class="line">			Arrays.<span class="built_in">fill</span>(cnts, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="comment">// 数字提取某一位的技巧</span></span><br><span class="line">				cnts[(arr[i] / offset) % BASE]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">				cnts[i] = cnts[i] + cnts[i - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				<span class="comment">// 前缀数量分区的技巧</span></span><br><span class="line">				<span class="comment">// 数字提取某一位的技巧</span></span><br><span class="line">				help[--cnts[(arr[i] / offset) % BASE]] = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				arr[i] = help[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><strong>左程云006</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>l、r 为区间左右端点，比较值为 target t（寻找 t）。需保证数组有序，若 ＞（m 为区间中点），则向右二分；若 ＜，则向左二分。当 <em>l</em>≥<em>r</em> 时结束，时间复杂度 <em>O</em>(log<em>n</em>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == target) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target) l = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h4><p>左程云051 <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>一只会code的小金鱼  <a target="_blank" rel="noopener" href="https://b23.tv/vFaRbc9">https://b23.tv/vFaRbc9</a></p>
<p>写函数f，f函数作用为得到一个过程的答案，二分从最极限的最大可能到最小可能答案。我们则可以同f判断能否达到题目的需求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) sum += x / b[i] * a[i];</span><br><span class="line">    <span class="keyword">return</span> sum &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binaryAnswer</span><span class="params">(<span class="type">int</span> n, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(m, n, a, b)) &#123; ans = m; r = m - <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">例</span><br><span class="line"></span><br><span class="line">n台打印机，每台打印机的效率分别是a张b秒。</span><br><span class="line"></span><br><span class="line">问打印到第n张纸是多少秒</span><br><span class="line"></span><br><span class="line">设打印第n张纸x秒</span><br><span class="line"></span><br><span class="line">f函数可以求出x秒时具体可以打印多少张纸</span><br><span class="line"></span><br><span class="line">x/b*a和n张比，够了记答案往左二分，不够则不记答案往右二分，最大给<span class="number">1e9</span></span><br></pre></td></tr></table></figure>



<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><p>（用数组模拟 列竖式计算）</p>
<p>麦克老师讲算法 高精度算法全套  <a target="_blank" rel="noopener" href="https://b23.tv/sArWoTg">https://b23.tv/sArWoTg</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/bignum/">高精度计算 - OI Wiki</a></p>
<h4 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h4><p>处理两个大整数相加，用数组存储每一位，模拟进位操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>, i = num<span class="number">1.</span><span class="built_in">size</span>() - <span class="number">1</span>, j = num<span class="number">2.</span><span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="type">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) sum += num1[i--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) sum += num2[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(sum % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h4><p>处理两个大整数相减，用数组存储每一位，模拟借位操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">subtract</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 &lt; num2) <span class="keyword">return</span> <span class="string">&quot;-&quot;</span> + <span class="built_in">subtract</span>(num2, num1);</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> borrow = <span class="number">0</span>, i = num<span class="number">1.</span><span class="built_in">size</span>() - <span class="number">1</span>, j = num<span class="number">2.</span><span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> diff = (num1[i] - <span class="string">&#x27;0&#x27;</span>) - borrow;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) diff -= (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123; diff += <span class="number">10</span>; borrow = <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> borrow = <span class="number">0</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(diff + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        i--; j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除前导零</span></span><br><span class="line">    <span class="keyword">while</span> (res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.<span class="built_in">back</span>() == <span class="string">&#x27;0&#x27;</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45629285/article/details/111146240?sharetype=blog&shareId=111146240&sharerefer=APP&sharesource=2401_87034440&sharefrom=link">https://blog.csdn.net/weixin_45629285/article/details/111146240?sharetype=blog&amp;shareId=111146240&amp;sharerefer=APP&amp;sharesource=2401_87034440&amp;sharefrom=link</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/basic/prefix-sum/">前缀和 &amp; 差分 - OI Wiki</a></p>
<h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><p>作用，可以快速求出区间l 到 r之间数之和。</p>
<p>只需要执行 <code>sum[r] - sum[l - 1]</code>。输出原序列中从第<code>l</code>个数到第r个数的和的时间复杂度变成了<code>O(1)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefixSum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询区间[l,r]的和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; sum, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[r + <span class="number">1</span>] - sum[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p><strong>二维前缀和预处理公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span> ] + a[i] [j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>以<code>(x1, y1)</code>为左上角，<code>(x2, y2)</code>为右下角的子矩阵的和为：<br><code>s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">prefixSum2D</span>(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询子矩阵(x1,y1)-(x2,y2)的和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query2D</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; s, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h4><p><strong>结论</strong>：给<code>a</code>数组中的<code>[ l, r] </code>区间中的每一个数都加上<code>c</code>,</p>
<p>只需对差分数组<code>b</code>做 <code>b[l] + = c</code>, <code>b[r+1] - = c </code>。</p>
<p>构造差分数组，差分为前缀和的逆运算。可以做到快速为数组中的每个值进行加减运算。</p>
<h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><p>(思路同一维)</p>
<p>构造方法，<strong>结论</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[i][j] = a[i][j] − a[i − 1][j] − a[i][j − 1] + a[i − 1 ][j − 1]</span><br></pre></td></tr></table></figure>



<h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><p><strong>左程云050</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>1有的双指针知识单纯用到两个指针</p>
<p>2有的则包含单调性（贪心）方面的思考与分析</p>
<p>常见类型：1）同向双指针 2）快慢双指针 3）从两端向中间的双指针</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><strong>左程云003 031 033</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>直接操作二进制位，用于高效计算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOdd</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &amp; <span class="number">1</span>; &#125; <span class="comment">// 判断奇偶</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &amp; -n; &#125; <span class="comment">// 获取最低位1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOnes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">// 计算二进制中1的个数</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>; <span class="comment">// 清除最低位1</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p><strong>左程云032</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>用bit组成数组存放值，用bit01代表存在与否，取存用位运算。</p>
<p>限制 必须连续范围，不能过大。</p>
<p>优点 极大的节省空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitset</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; set;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bitset</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        set.<span class="built_in">resize</span>((n + <span class="number">31</span>) / <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = num / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> bitPos = num % <span class="number">32</span>;</span><br><span class="line">        set[index] |= (<span class="number">1</span> &lt;&lt; bitPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = num / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> bitPos = num % <span class="number">32</span>;</span><br><span class="line">        set[index] &amp;= ~(<span class="number">1</span> &lt;&lt; bitPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = num / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> bitPos = num % <span class="number">32</span>;</span><br><span class="line">        set[index] ^= (<span class="number">1</span> &lt;&lt; bitPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = num / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> bitPos = num % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> ((set[index] &gt;&gt; bitPos) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p><strong>左程云048</strong></p>
<p>【算法讲解048【必备】二维前缀和、二维差分、离散化技巧】</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Wz4y1K74C?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Wz4y1K74C?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>将无限或大范围的数值映射到有限、连续的整数区间，保留相对大小关系，用于优化数据范围过大的问题（如坐标压缩、频率统计）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 离散化单个值x（tmp为排序去重后的数组）</span></span><br><span class="line"><span class="type">int</span> idx = <span class="built_in">lower_bound</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), x) - tmp.<span class="built_in">begin</span>();</span><br><span class="line">lower_bound 返回第一个≥当前值的位置，保证相同值映射到同一下标</span><br><span class="line">    </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">discretize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp = nums;</span><br><span class="line">    <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">    tmp.<span class="built_in">erase</span>(<span class="built_in">unique</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>()), tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        x = <span class="built_in">lower_bound</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), x) - tmp.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>合并重叠区间，先按左端点排序，再遍历合并。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merged;</span><br><span class="line">    merged.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interval[<span class="number">0</span>] &lt;= merged.<span class="built_in">back</span>()[<span class="number">1</span>])</span><br><span class="line">            merged.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(merged.<span class="built_in">back</span>()[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            merged.<span class="built_in">push_back</span>(interval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>【【强烈推荐】深入浅出数据结构 - 顶尖程序员图文讲解 - UP主翻译校对 (已完结)】</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fv4y1f7T1?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Fv4y1f7T1?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><strong>存储特点</strong>：</p>
<p>使用二维数组 <code>g[i][j]</code> 表示顶点 <code>i</code> 到 <code>j</code> 的连接关系</p>
<p>无向图的矩阵是对称的，有向图可能不对称</p>
<p>矩阵中 <code>1</code> 表示有边，<code>0</code> 或 <code>∞</code> 表示无边（带权图存储权重值）</p>
<p><strong>优点</strong>：</p>
<ol>
<li>实现简单，支持快速查询任意两顶点间是否有边（O (1)）</li>
<li>便于计算每个顶点的度（行 &#x2F; 列和）</li>
<li>适合稠密图（边数接近顶点数平方）</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>空间复杂度高（O (V²)），存储稀疏图时浪费大量空间（V：顶点vertex E：边edge）</li>
<li>添加 &#x2F; 删除顶点需重新调整矩阵大小，效率低</li>
<li>统计边的总数需要遍历整个矩阵（O (V²)）</li>
</ol>
<h4 id="链表与邻接表"><a href="#链表与邻接表" class="headerlink" title="链表与邻接表"></a>链表与邻接表</h4><p><strong>优点</strong>：</p>
<ol>
<li>空间效率高（O (V+E)），适合稀疏图（边数远小于顶点数平方）</li>
<li>便于添加 &#x2F; 删除顶点和边</li>
<li>遍历所有边的时间复杂度为 O (E)</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>判断两顶点间是否有边效率较低（O (degree (v))）</li>
<li>计算顶点的度需遍历对应链表（O (degree (v))）</li>
<li>不适合频繁查询任意两顶点间的关系</li>
</ol>
<h4 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h4><h5 id="最小栈（O-1-获取最小值）"><a href="#最小栈（O-1-获取最小值）" class="headerlink" title="最小栈（O (1) 获取最小值）"></a>最小栈（O (1) 获取最小值）</h5><p><strong>左程云015</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15X4y177cM?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV15X4y177cM?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>维护一个最小栈minval包含getmin功能   若入栈元素x小于等于最小栈的栈顶则x入最小栈</p>
<p>minVal.empty() || x &lt;&#x3D; minVal.top()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; data, minVal;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (minVal.<span class="built_in">empty</span>() || x &lt;= minVal.<span class="built_in">top</span>())</span><br><span class="line">            minVal.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">top</span>() == minVal.<span class="built_in">top</span>())</span><br><span class="line">            minVal.<span class="built_in">pop</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> minVal.<span class="built_in">top</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="单调栈（下一个更大元素）"><a href="#单调栈（下一个更大元素）" class="headerlink" title="单调栈（下一个更大元素）"></a>单调栈（下一个更大元素）</h5><p>实现原理：以单调递增栈为例，当新元素入栈时，会将栈中所有比它大的元素弹出，直到栈为空或者栈顶元素小于等于新元素，然后将新元素入栈。单调递减栈则相反。</p>
<p>遍历每个元素时，将当前元素与栈顶元素比较：</p>
<p>若当前元素<strong>小于等于</strong>栈顶元素 → 直接入栈，保持栈的递增性</p>
<p>若当前元素大于栈顶元素 → 触发以下操作：</p>
<ol>
<li><strong>弹出栈顶元素</strong>，并记录当前元素为其「下一个更大值」</li>
<li><strong>持续弹出</strong>新的栈顶元素，直到当前元素 ≤ 栈顶</li>
<li><strong>当前元素入栈</strong>，恢复栈的递增顺序</li>
</ol>
<p>这个过程中，每个元素被弹出时，其「下一个更大值」即为触发弹出的当前元素。遍历结束后，栈内剩余元素的「下一个更大值」均为默认值（如 - 1 或无穷大）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            res[st.<span class="built_in">top</span>()] = nums[i];</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="单调队列（滑动窗口最大值）"><a href="#单调队列（滑动窗口最大值）" class="headerlink" title="单调队列（滑动窗口最大值）"></a>单调队列（滑动窗口最大值）</h5><p>实现原理：通常用双端队列来实现。以单调递增队列为例，当新元素要入队时，从队尾开始比较，如果队尾元素大于新元素，则将队尾元素出队，直到队尾元素小于等于新元素或者队列为空，然后将新元素从队尾入队。在进行出队操作时，如果队首元素超出了当前考虑的范围，则将队首元素出队。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 移除队尾较小元素</span></span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 移除窗口外元素</span></span><br><span class="line">        <span class="keyword">if</span> (dq.<span class="built_in">front</span>() &lt;= i - k)</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="KMP-算法以及find-字符串匹配"><a href="#KMP-算法以及find-字符串匹配" class="headerlink" title="KMP 算法以及find()字符串匹配"></a>KMP 算法以及find()字符串匹配</h4><p><strong>左程云100</strong> 、<strong>101</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>核心思想：利用已经匹配过的部分信息，避免不必要的字符比较，从而提高匹配效率。</p>
<p>通过预处理模式串的 next 数组，记录模式串中每个位置之前最长的相同前缀和后缀长度。</p>
<p><strong>Next 数组含义</strong>：<br><code>next[i]</code> 表示模式串 <code>pattern[0..i]</code> 的<strong>最长公共前后缀长度</strong>。<br>例如：<code>pattern = &quot;ababc&quot;</code>，其 <code>next</code> 数组为 <code>[0, 0, 1, 2, 0]</code>。</p>
<p><strong>匹配过程优化</strong>：<br>当主串 <code>S[i]</code> 与模式串 <code>P[j]</code> 不匹配时，直接将 <code>j</code> 回退到 <code>next[j-1]</code>，而<strong>主串指针 <code>i</code> 不回退</strong>。</p>
<p><strong>总结</strong>：KMP 通过预处理模式串，记录每个位置的最长公共前后缀长度，在匹配失败时快速回退模式串指针，避免主串重复扫描。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;hello world, world!&quot;</span>;</span><br><span class="line">    string substr = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    string charset = <span class="string">&quot;aeiou&quot;</span>;</span><br><span class="line">    string digits = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">    <span class="comment">// 1. 基本查找：find() 和 rfind()</span></span><br><span class="line">    <span class="type">size_t</span> pos1 = str.<span class="built_in">find</span>(substr);            <span class="comment">// 正向查找子串，返回6</span></span><br><span class="line">    <span class="type">size_t</span> pos2 = str.<span class="built_in">find</span>(substr, <span class="number">7</span>);         <span class="comment">// 从位置7开始查找，返回13</span></span><br><span class="line">    <span class="type">size_t</span> pos3 = str.<span class="built_in">rfind</span>(substr);           <span class="comment">// 反向查找子串，返回13</span></span><br><span class="line">    <span class="type">size_t</span> pos4 = str.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>);               <span class="comment">// 查找字符，返回4</span></span><br><span class="line">    <span class="type">size_t</span> pos5 = str.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">5</span>);            <span class="comment">// 从位置5开始查找字符，返回7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查找任意字符：find_first_of() 和 find_last_of()</span></span><br><span class="line">    <span class="type">size_t</span> pos6 = str.<span class="built_in">find_first_of</span>(charset);  <span class="comment">// 查找首个元音字母，返回1(&#x27;e&#x27;)</span></span><br><span class="line">    <span class="type">size_t</span> pos7 = str.<span class="built_in">find_last_of</span>(charset);   <span class="comment">// 查找最后一个元音字母，返回11(&#x27;o&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查找非指定字符：find_first_not_of() 和 find_last_not_of()</span></span><br><span class="line">    string spaces = <span class="string">&quot;   abc   &quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> pos8 = spaces.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>); <span class="comment">// 查找首个非空格字符，返回3(&#x27;a&#x27;)</span></span><br><span class="line">    <span class="type">size_t</span> pos9 = spaces.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);  <span class="comment">// 查找最后一个非空格字符，返回5(&#x27;c&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 遍历所有匹配位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有 &#x27;world&#x27; 的位置：&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> currentPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((currentPos = str.<span class="built_in">find</span>(substr, currentPos)) != string::npos) &#123;</span><br><span class="line">        cout &lt;&lt; currentPos &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        currentPos += substr.<span class="built_in">length</span>(); <span class="comment">// 跳过已匹配的部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">// 输出: 6 13</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 检查字符串是否包含子串</span></span><br><span class="line">    <span class="type">bool</span> hasWorld = (str.<span class="built_in">find</span>(substr) != string::npos); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 处理未找到的情况</span></span><br><span class="line">    <span class="type">size_t</span> notFound = str.<span class="built_in">find</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (notFound == string::npos) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#x27;xyz&#x27; 未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 特殊情况：空字符串查找</span></span><br><span class="line">    <span class="type">size_t</span> emptyPos = str.<span class="built_in">find</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 始终返回0（空字符串被视为存在于字符串开头）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 查找首个非数字字符</span></span><br><span class="line">    string numStr = <span class="string">&quot;123.45&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> dotPos = numStr.<span class="built_in">find_first_not_of</span>(digits); <span class="comment">// 返回3(&#x27;.&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出所有结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos1: &quot;</span> &lt;&lt; pos1 &lt;&lt; endl; <span class="comment">// 6</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos2: &quot;</span> &lt;&lt; pos2 &lt;&lt; endl; <span class="comment">// 13</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos3: &quot;</span> &lt;&lt; pos3 &lt;&lt; endl; <span class="comment">// 13</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos4: &quot;</span> &lt;&lt; pos4 &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos5: &quot;</span> &lt;&lt; pos5 &lt;&lt; endl; <span class="comment">// 7</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos6: &quot;</span> &lt;&lt; pos6 &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos7: &quot;</span> &lt;&lt; pos7 &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos8: &quot;</span> &lt;&lt; pos8 &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos9: &quot;</span> &lt;&lt; pos9 &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hasWorld: &quot;</span> &lt;&lt; (hasWorld ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl; <span class="comment">// true</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dotPos: &quot;</span> &lt;&lt; dotPos &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Trie-树（字典树）"><a href="#Trie-树（字典树）" class="headerlink" title="Trie 树（字典树）"></a>Trie 树（字典树）</h4><p><strong>左程云044</strong> <strong>045</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>Trie 树通过共享字符串前缀存储多组单词，使查询效率仅取决于字符串长度，适合高频前缀匹配场景。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    vector&lt;TrieNode*&gt; children;  <span class="comment">// 子节点数组（假设仅包含小写字母）</span></span><br><span class="line">    <span class="type">bool</span> isEndOfWord;            <span class="comment">// 标记是否为单词结尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">children</span>(<span class="number">26</span>, <span class="literal">nullptr</span>), <span class="built_in">isEndOfWord</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123; root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[idx]) &#123;</span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEndOfWord = <span class="literal">true</span>;  <span class="comment">// 标记单词结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找字符串</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找前缀</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 辅助函数：查找前缀路径</span></span><br><span class="line">    <span class="function">TrieNode* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[idx]) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="并查集（合并查询集合）"><a href="#并查集（合并查询集合）" class="headerlink" title="并查集（合并查询集合）"></a>并查集（合并查询集合）</h4><p><strong>蓝不过海呀</strong> </p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zZRSYUEWV?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1zZRSYUEWV?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p><strong>麦克老师讲算法</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jv411a7LK?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1jv411a7LK?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>合并 查询 集合</p>
<p>用数组 保存每个节点的父亲</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        p[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rootx = <span class="built_in">Find</span>(x);</span><br><span class="line">    <span class="type">int</span> rooty = <span class="built_in">Find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(rootx!=rooty)&#123;<span class="comment">//按大小合并</span></span><br><span class="line">        <span class="keyword">if</span>(p[rootx]&lt;p[rooty])&#123;</span><br><span class="line">            p[rooty]=rootx;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[rootx]&gt;p[rooty])&#123;</span><br><span class="line">            p[rootx]=rooty;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[rootx]=rooty;</span><br><span class="line">            p[rooty]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rootx!=rooty)&#123;<span class="comment">//按照高度合并</span></span><br><span class="line">        <span class="keyword">if</span>(p[rootx]&lt;p[rooty])&#123;</span><br><span class="line">            p[rootx]+=p[rooty];</span><br><span class="line">            p[rooty]=rootx;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p[rooty]+=p[rootx];</span><br><span class="line">            p[rootx]=rooty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find</span>(p[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆（优先队列）"><a href="#堆（优先队列）" class="headerlink" title="堆（优先队列）"></a>堆（优先队列）</h4><p><strong>高效维护和获取极值（最大值或最小值）</strong>，并支持快速插入、删除操作。一般使用stl库中函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br></pre></td></tr></table></figure>

<h4 id="Hash-表（两数之和）"><a href="#Hash-表（两数之和）" class="headerlink" title="Hash 表（两数之和）"></a>Hash 表（两数之和）</h4><p><strong>左程云026</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>作用为快速查找 &#x2F; 统计</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13m4y1p7VB?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV13m4y1p7VB?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p><strong>只用存元素</strong>  <code>unordered_set</code>      <strong>需要存元素 + 额外信息</strong>  <code>unordered_map</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="comment">/*去重 / 判重	unordered_set	自动去重，仅需检查元素存在性（如判断数组是否有重复元素）。</span></span><br><span class="line"><span class="comment">统计频率 / 映射关系	unordered_map	需要存储键值对（如统计字符出现次数、记录节点距离）。</span></span><br><span class="line"><span class="comment">缓存中间结果	unordered_map	需要同时存储输入和计算结果（如记忆化搜索）。</span></span><br><span class="line"><span class="comment">快速查找补数 / 配对	unordered_map	需要键值对关联（如两数之和问题，需快速查找目标值的补数）。*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x, y; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PH</span> &#123; <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.x ^ p.y; <span class="comment">// 简化哈希函数</span></span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基础用法</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">4</span>);        <span class="comment">// 插入</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">2</span>);         <span class="comment">// 删除</span></span><br><span class="line">    <span class="type">bool</span> exists = s.<span class="built_in">count</span>(<span class="number">3</span>); <span class="comment">// 存在检查</span></span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">find</span>(<span class="number">1</span>); <span class="comment">// 迭代器查找</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义类型</span></span><br><span class="line">    unordered_set&lt;Point, PH&gt; points;</span><br><span class="line">    points.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : s) &#123; <span class="comment">/* 使用e */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h3><h4 id="DFS-与-BFS"><a href="#DFS-与-BFS" class="headerlink" title="DFS 与 BFS"></a>DFS 与 BFS</h4><h5 id="DFS（深度优先搜索）"><a href="#DFS（深度优先搜索）" class="headerlink" title="DFS（深度优先搜索）"></a>DFS（深度优先搜索）</h5><p><strong>一只会code的小金鱼</strong>  <a target="_blank" rel="noopener" href="https://b23.tv/vFaRbc9">https://b23.tv/vFaRbc9</a></p>
<p>排列，指数级 深入探索分支至无法继续，然后回溯后探索其他分支。核心在于递归</p>
<p>DFS适合此类题目：给定初始状态跟目标状态，要求判断从初始状态到目标状态是否有解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, <span class="type">int</span> u, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : adj[u])</span><br><span class="line">        <span class="keyword">if</span> (!visited[v])</span><br><span class="line">            <span class="built_in">dfs</span>(adj, v, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS（广度优先搜索）"><a href="#BFS（广度优先搜索）" class="headerlink" title="BFS（广度优先搜索）"></a>BFS（广度优先搜索）</h5><p>**左程云062  ** <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p><strong>一只会code的小金鱼</strong> <a target="_blank" rel="noopener" href="https://b23.tv/vFaRbc9">https://b23.tv/vFaRbc9</a></p>
<p>队列，逐层扩散，扩散几层最短路就是多少，可以单点弹出，整层弹出。标记状态数组，剪枝。</p>
<p>使用要求：任意两相邻节点距离等同(边权相同)。</p>
<p>二段性：一边全符合，另一边全不符合，且队列内最多两种状态。x和x+1。</p>
<p>bfs队列具有的性质：单调性 单调增减</p>
<h5 id="多源bfs"><a href="#多源bfs" class="headerlink" title="多源bfs"></a>多源bfs</h5><p>提前把源头存入队列(有个虚拟的源点连接多个边权为0的点(多个源头))。</p>
<h5 id="01bfs"><a href="#01bfs" class="headerlink" title="01bfs"></a>01bfs</h5><p>双端队列 队头入队or队尾入队</p>
<h5 id="双向bfs"><a href="#双向bfs" class="headerlink" title="双向bfs"></a>双向bfs</h5><p><strong>左程云063</strong></p>
<p>维护两个队列，需要知道起点和终点位置，从起点和终点同时开始bfs，维护状态数组记录两个bfs到的状态，若碰上则证明可以从起点到终点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = adj.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dist[v] = dist[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="拓扑排序（有向无环图）"><a href="#拓扑排序（有向无环图）" class="headerlink" title="拓扑排序（有向无环图）"></a>拓扑排序（有向无环图）</h4><p><strong>拓扑排序</strong>是对 ** 有向无环图（DAG）** 的顶点进行排序的算法，使得对于每条有向边 (u→v)，顶点 u 在排序中均出现在 v 之前，常用 Kahn 算法（入度队列）或 DFS 实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topologicalSort</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edges : adj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : edges)</span><br><span class="line">            inDegree[v]++;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u])</span><br><span class="line">            <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">size</span>() == n ? res : <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h4><p><strong>左程云064</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Cm4y1g77W?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Cm4y1g77W?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<h5 id="Dijkstra-算法（单源最短路径）"><a href="#Dijkstra-算法（单源最短路径）" class="headerlink" title="Dijkstra 算法（单源最短路径）"></a>Dijkstra 算法（单源最短路径）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; <span class="comment">// &#123;距离, 节点编号&#125;</span></span><br><span class="line"><span class="comment">// 输入：邻接表graph，源点src，输出：源点到各点的最短距离数组dist</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;PII&gt;&gt;&amp; graph, <span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// 初始化距离为无穷大</span></span><br><span class="line">    dist[src] = <span class="number">0</span>; <span class="comment">// 源点到自身距离为0</span></span><br><span class="line">    <span class="comment">// 最小堆（优先队列）</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, src&#125;); <span class="comment">// &#123;距离, 节点&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, u] = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过已处理的节点（避免重复计算）</span></span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有邻接边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : graph[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &gt; dist[u] + w) &#123;</span><br><span class="line">                dist[v] = dist[u] + w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// 节点数</span></span><br><span class="line">    vector&lt;vector&lt;PII&gt;&gt; <span class="built_in">graph</span>(n); <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="comment">// 添加边 (u-&gt;v 权重为w)</span></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// 0-&gt;1 权重2</span></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">4</span>&#125;); <span class="comment">// 0-&gt;2 权重4</span></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">1</span>&#125;); <span class="comment">// 1-&gt;2 权重1</span></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">7</span>&#125;); <span class="comment">// 1-&gt;3 权重7</span></span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">3</span>&#125;); <span class="comment">// 2-&gt;3 权重3</span></span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">2</span>&#125;); <span class="comment">// 3-&gt;4 权重2</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dist = <span class="built_in">dijkstra</span>(graph, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;从节点0到节点&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的最短距离是: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] == INT_MAX) cout &lt;&lt; <span class="string">&quot;INF&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="a-算法"><a href="#a-算法" class="headerlink" title="a*算法"></a>a*算法</h5><p><strong>左程云065</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1t94y187zW?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1t94y187zW?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>问从特定点到特定点的最短距离</p>
<p>与dijkstra算法distance数组相同，区别在小根堆的使用时加一个曼哈顿距离(估计一个长度，影响小根堆弹出顺序，致使运行时间缩短)</p>
<h5 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/geometry/distance/">距离 - OI Wiki</a></p>
<p><strong>欧氏距离</strong>，一般也称作欧几里得距离，空间两点间的欧氏距离为：根号下a方+b方+c方</p>
<p>缺点：两个整点计算其欧氏距离时，往往答案是浮点型，会存在一定误差。</p>
<p><strong>曼哈顿距离</strong>（Manhattan distance）</p>
<p>为它们横坐标之差的绝对值与纵坐标之差的绝对值之和。可以表示为：|x1-x2|+|y1-y2|</p>
<p>[P5098 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5098">USACO04OPEN] Cave Cows 3 - 洛谷</a></p>
<p><strong>切比雪夫距离</strong></p>
<p>是向量空间中的一种度量，二个点之间的距离定义为其各坐标数值差的最大值。</p>
<p>二维中表示为：max(|x1-x2|,|y1-y2|)</p>
<p>如果将曼哈顿距离转换成切比雪夫距离</p>
<p>那么圆形的辐射范围变成了一个矩形，可以用O(n²)扫描线，扫描圆形辐射范围</p>
<h5 id="Floyd-算法（多源最短路径）"><a href="#Floyd-算法（多源最短路径）" class="headerlink" title="Floyd 算法（多源最短路径）"></a>Floyd 算法（多源最短路径）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dist)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = dist.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p><strong>左程云061</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sK4y1F7LH?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1sK4y1F7LH?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>包含Kruskal prim及其优化</p>
<h3 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h3><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/number-theory/sieve/">筛法 - OI Wiki</a></p>
<h4 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h4><p>思路 ：对于任意一个大于1  的正整数 ，那么它的 x倍就是合数（x&gt;1）。利用这个结论，我们可以避免很多次不必要的检测。</p>
<p>如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。</p>
<p>这种 <strong>线性筛法</strong> 也称为 <strong>Euler 筛法</strong>（欧拉筛法）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; pri;</span><br><span class="line"><span class="type">bool</span> not_prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!not_prime[i]) &#123;</span><br><span class="line">      pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pri_j : pri) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * pri_j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">      not_prime[i * pri_j] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri_j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// i % pri_j == 0</span></span><br><span class="line">        <span class="comment">// 换言之，i 之前被 pri_j 筛过了</span></span><br><span class="line">        <span class="comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被</span></span><br><span class="line">        <span class="comment">// pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break</span></span><br><span class="line">        <span class="comment">// 掉就好了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="欧拉函数（φ-n-）"><a href="#欧拉函数（φ-n-）" class="headerlink" title="欧拉函数（φ(n)）"></a>欧拉函数（φ(n)）</h4><p>计算小于等于 n 且与 n 互质的数的个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; pri;</span><br><span class="line"><span class="type">bool</span> not_prime[N];</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!not_prime[i]) &#123;</span><br><span class="line">      pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">      phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pri_j : pri) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * pri_j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">      not_prime[i * pri_j] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri_j == <span class="number">0</span>) &#123;</span><br><span class="line">        phi[i * pri_j] = phi[i] * pri_j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      phi[i * pri_j] = phi[i] * phi[pri_j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p><strong>左程云098</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13k4y1D7Dn?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV13k4y1D7Dn?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>计算 a*b mod <em>m</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fastPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a % m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><p>返回mat^power % mod</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix_pow</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat, <span class="type">int</span> power, <span class="type">int</span> mod) &#123;</span><br><span class="line"><span class="type">int</span> n = mat.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单位矩阵</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (power % <span class="number">2</span> == <span class="number">1</span>) res = <span class="built_in">multiply</span>(res, mat, mod);</span><br><span class="line"></span><br><span class="line">    mat = <span class="built_in">multiply</span>(mat, mat, mod);</span><br><span class="line"></span><br><span class="line">    power /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最大公约数（GCD）"><a href="#最大公约数（GCD）" class="headerlink" title="最大公约数（GCD）"></a>最大公约数（GCD）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小公倍数（LCM）"><a href="#最小公倍数（LCM）" class="headerlink" title="最小公倍数（LCM）"></a>最小公倍数（LCM）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>左程云</strong>066——088</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ww41167Ac?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Ww41167Ac?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p><strong>一只会code的小金鱼</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1r84y1379W?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1r84y1379W?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>给定一个问题，拆分为一个个子问题，直到子问题得到解决。保存子问题答案以减少重复计算。(记忆化搜索)再根据子问题答案反推，得到原问题解。</p>
<p>动态规划是递推的子集？</p>
<p>例题:跳台阶  一个楼梯n级台阶，每次走一或两级，问从0到n有多少种方案。</p>
<p>记忆化搜索(dfs+记录答案)想实现记忆化搜索，dfs的参数应该尽可能少，不应该传入不影响边界的参数。</p>
<p>剪枝则应该尽可能把能剪枝的参数传入保留</p>
<p>递归 递分解问题 自顶向下，归得到答案 自底向上。只进行归可不可以？从下逐层往上推</p>
<p>递推公式(dfs向下递归公式)</p>
<p>线性dp 例洛谷u224502</p>
<p>阿福是经验丰富大盗，要洗劫有N家店铺的一条街，每家店有现金。</p>
<p>已知同时洗劫相邻店铺报警系统会启动，阿福不想被抓，给定T组数据，每组数据先给店铺数N，再给N家店铺现金数，求每组数据下 阿福在不惊动警察时最多能得的现金数。</p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><strong>左程云</strong>089——094</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1be41167yw?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1be41167yw?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p><strong>湖北工业大学</strong>ACM集训队 2025寒假培训第四讲——贪心初步</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KGcBeVEyW?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1KGcBeVEyW?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<h4 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h4><p>选择最多的不重叠活动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxActivities</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; activities)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(activities.<span class="built_in">begin</span>(), activities.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>, lastEnd = activities[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; activities.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activities[i][<span class="number">0</span>] &gt;= lastEnd) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            lastEnd = activities[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈夫曼编码（最小带权路径长度）"><a href="#哈夫曼编码（最小带权路径长度）" class="headerlink" title="哈夫曼编码（最小带权路径长度）"></a>哈夫曼编码（最小带权路径长度）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> freq;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> f) : <span class="built_in">freq</span>(f), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* a, Node* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;freq &gt; b-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">huffman</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; freq)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node*, vector&lt;Node*&gt;, Compare&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> f : freq)</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(f));</span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Node* a = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        Node* b = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        Node* parent = <span class="keyword">new</span> <span class="built_in">Node</span>(a-&gt;freq + b-&gt;freq);</span><br><span class="line">        parent-&gt;left = a;</span><br><span class="line">        parent-&gt;right = b;</span><br><span class="line">        pq.<span class="built_in">push</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.<span class="built_in">top</span>()-&gt;freq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="博弈类问题"><a href="#博弈类问题" class="headerlink" title="博弈类问题"></a>博弈类问题</h3><p><strong>左程云095</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1T5411i7Gg?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1T5411i7Gg?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>简单博弈类问题情境下，每个局面仅存在两种可能：先手必胜（后手必败）和先手必败（后手必胜）状态</p>
<p>简称为 <strong>必胜态</strong> <strong>必败态</strong></p>
<h4 id="巴什博弈（Bash-Game）"><a href="#巴什博弈（Bash-Game）" class="headerlink" title="巴什博弈（Bash Game）"></a>巴什博弈（Bash Game）</h4><p><strong>简述</strong>：两人轮流从一堆物品中取物，每次至少取 1 个，最多取<code>m</code>个，取走最后一个物品者胜。</p>
<p><strong>结论</strong>：若物品总数<code>n</code>能被<code>m+1</code>整除，则后手必胜；否则先手必胜。<br>（核心：先手可通过取<code>n mod (m+1)</code>个物品，使剩余数量为<code>m+1</code>的倍数，后续镜像后手操作即可获胜。）</p>
<h4 id="尼姆博弈（Nim-Game）"><a href="#尼姆博弈（Nim-Game）" class="headerlink" title="尼姆博弈（Nim Game）"></a>尼姆博弈（Nim Game）</h4><p><strong>简述</strong>：两人轮流从多堆物品中选一堆，取走任意数量（至少 1 个），取走最后一个物品者胜。</p>
<p><strong>结论</strong>：计算所有堆物品数量的<strong>异或和</strong>（XOR）。若异或和为 0，则后手必胜；否则先手必胜。<br>（核心：先手可通过操作使各堆数量异或和为 0，后续镜像后手操作即可获胜。）</p>
<h4 id="斐波那契博弈（Fibonacci-Game）"><a href="#斐波那契博弈（Fibonacci-Game）" class="headerlink" title="斐波那契博弈（Fibonacci Game）"></a>斐波那契博弈（Fibonacci Game）</h4><p><strong>简述</strong>：一堆物品共<code>n</code>个，两人轮流取物，先手首次取 1 到<code>n-1</code>个，之后每次取物数量不超过对手上一次取物数量的 2 倍，取走最后一个物品者胜。</p>
<p><strong>结论</strong>：若<code>n</code>是<strong>斐波那契数</strong>，则后手必胜；否则先手必胜。<br>（核心：斐波那契数构成必败态，非斐波那契数可分解为两个不连续的斐波那契数，先手通过取走较小数打破平衡。）</p>
<h4 id="威佐夫博弈（Wythoff-Game）"><a href="#威佐夫博弈（Wythoff-Game）" class="headerlink" title="威佐夫博弈（Wythoff Game）"></a>威佐夫博弈（Wythoff Game）</h4><p><strong>简述</strong>：两人轮流从两堆物品中取物，可从一堆取任意数量，或从两堆取相同数量，取走最后一个物品者胜。</p>
<p><strong>结论</strong>：设两堆数量为<code>(a, b)</code>（<code>a ≤ b</code>），计算<code>k = b - a</code>。若<code>a = ⌊k * (√5 + 1)/2⌋</code></p>
<p>（黄金分割数≈1.618），则后手必胜；否则先手必胜。</p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/game-theory/impartial-game/">公平组合游戏 - OI Wiki</a></p>
<p>图游戏概念：每个博弈局面对应图中一个点，行动对应点到后继点的边，必败局面视为无后继节点的点</p>
<h4 id="公平组合游戏（ICG）"><a href="#公平组合游戏（ICG）" class="headerlink" title="公平组合游戏（ICG）"></a>公平组合游戏（ICG）</h4><ul>
<li>可抽象为有向无环图，符合图游戏规则</li>
</ul>
<h4 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h4><p><strong>左程云096</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N94y1T7Mb?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1N94y1T7Mb?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<ol>
<li><p>定义</p>
<p>通过 mex（最小非负未出现整数）计算</p>
<p>必败点 SG 值 &#x3D; 0</p>
<p>非必败点 SG 值 &#x3D; 所有后继节点 SG 值的 mex</p>
</li>
<li><p>判定</p>
<p>SG≠0 → 必胜态</p>
<p>SG&#x3D;0 → 必败态</p>
</li>
</ol>
<h4 id="SG-定理（Bouton-定理）"><a href="#SG-定理（Bouton-定理）" class="headerlink" title="SG 定理（Bouton 定理）"></a>SG 定理（Bouton 定理）</h4><p>总游戏 SG 值 &#x3D; 各独立子游戏 SG 值的异或和，适用所有 ICG 游戏。</p>
<h3 id="算法学习笔记-1"><a href="#算法学习笔记-1" class="headerlink" title="算法学习笔记"></a>算法学习笔记</h3><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>此笔记大致按照<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/introduction/11/">AcWing - 算法基础课</a>顺序整理，各算法中的链接绝大部分为我真实在b站学完的网课，还包含部分CSDN和OI维基百科中的内容，希望对你有所帮助。</p>
<h3 id="排序算法-1"><a href="#排序算法-1" class="headerlink" title="排序算法"></a>排序算法</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_80215560/article/details/136604635?sharetype=blog&shareId=136604635&sharerefer=APP&sharesource=2401_87034440&sharefrom=link">https://blog.csdn.net/2301_80215560/article/details/136604635?sharetype=blog&amp;shareId=136604635&amp;sharerefer=APP&amp;sharesource=2401_87034440&amp;sharefrom=link</a></p>
<p><strong>左程云</strong>   <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/algorithmzuo/algorithm-journey">https://github.com/algorithmzuo/algorithm-journey</a></p>
<p>004 021 023 025 028 029</p>
<h4 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>相邻两个元素的值进行两两比较，若发现前一个数大于后一个数则交换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>;<span class="comment">//不能是n，不然会越界</span></span><br><span class="line">	<span class="keyword">while</span>(end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">bool</span> exchange = <span class="literal">false</span>;<span class="comment">//优化，比较之后没有交换，说明已经排好了，就break循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">swap</span>(&amp;a[i], &amp;a[i + <span class="number">1</span>]);<span class="comment">//交换</span></span><br><span class="line">				exchange++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (exchange == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>左程云021、022</strong>  <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>拆分原数组，分别排序，再 merge 归并。归并排序是一种稳定的排序算法，时间复杂度为 <em>O</em>(<em>n</em>log<em>n</em>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(m - l + <span class="number">1</span>)</span>, <span class="title">R</span><span class="params">(r - m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.<span class="built_in">size</span>(); ++i) L[i] = nums[l + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; R.<span class="built_in">size</span>(); ++j) R[j] = nums[m + <span class="number">1</span> + j];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L.<span class="built_in">size</span>() &amp;&amp; j &lt; R.<span class="built_in">size</span>())</span><br><span class="line">        nums[k++] = L[i] &lt;= R[j] ? L[i++] : R[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L.<span class="built_in">size</span>()) nums[k++] = L[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; R.<span class="built_in">size</span>()) nums[k++] = R[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, l, m);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">merge</span>(nums, l, m, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="桶排序、基数排序、计数排序-1"><a href="#桶排序、基数排序、计数排序-1" class="headerlink" title="桶排序、基数排序、计数排序"></a>桶排序、基数排序、计数排序</h4><p><strong>左程云028</strong></p>
<p>这三种排序算法都不基于比较，对数据特征有要求。计数排序适用于已知数值范围的场景；基数排序通常要求处理十进制非负整数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">思路：大问题化小</span><br><span class="line">桶排序(Bucket sort)或所谓的箱排序，是一种分块的排序算法，工作的原理是将数组分到有限数量的桶里，</span><br><span class="line">每个桶的大小都相等。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</span><br><span class="line">把待排序序列（数组）中的数据根据函数映射方法分配到若干个桶中，</span><br><span class="line">在分别对各个桶进行排序，最后依次按顺序取出桶中的数据。</span><br><span class="line">适用于数据分配均匀，数据比较大，相对集中的情况。</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">double</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">buckets</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> num : arr) &#123;</span><br><span class="line">        <span class="type">int</span> idx = n * num;</span><br><span class="line">        buckets[idx].<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; bucket : buckets) <span class="built_in">sort</span>(bucket.<span class="built_in">begin</span>(), bucket.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; bucket : buckets)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> num : bucket) arr[idx++] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序 一种特殊的排序，没有比较</span></span><br><span class="line">例（仅有<span class="number">0</span><span class="number">-10</span>）</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">以数组的下标当做数值，有这个数的时候a[i]++; </span><br><span class="line">局限：适用于整数。数要求集中（否则空间的浪费大）</span><br></pre></td></tr></table></figure>



<h4 id="基数排序-一般要求为十进制非负整数-1"><a href="#基数排序-一般要求为十进制非负整数-1" class="headerlink" title="基数排序(一般要求为十进制非负整数)"></a>基数排序(一般要求为十进制非负整数)</h4><p><strong>左程云028</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Lh4y1c7Aw?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Lh4y1c7Aw?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>判断最大的位数是几位，对每一位进行桶排序。</p>
<p>从个位开始，数组按个位数字大小入桶，然后从0-9倒出，此后十位百位同上循环，最终结果即有序。从低位开始作用为保留低位大小关系。</p>
<p><strong>技巧1 前缀分区做桶排列</strong></p>
<p>统计每个数字出现次数后做前缀和得到数组(x)，则从右向左遍历原数组时，该数字在保留相对次序情况下应该出现在x数组对应的数字-1的位置，做完此操作后x数组对应数字–。</p>
<p>故该技巧可以用于基数排序时对每一位数字进行排序任务。</p>
<p><strong>技巧2 怎么得到每一位</strong></p>
<p>用一个变量offset初始化为1，所求数字n。(n&#x2F;offset)%10该位数操作玩后offset*&#x3D;10依次得到每一位数字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">最终code</span><br><span class="line">    <span class="comment">// 理解的时候可以假设BASE = 10</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> offset = <span class="number">1</span>; bits &gt; <span class="number">0</span>; offset *= BASE, bits--) &#123;</span><br><span class="line">			Arrays.<span class="built_in">fill</span>(cnts, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="comment">// 数字提取某一位的技巧</span></span><br><span class="line">				cnts[(arr[i] / offset) % BASE]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">				cnts[i] = cnts[i] + cnts[i - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				<span class="comment">// 前缀数量分区的技巧</span></span><br><span class="line">				<span class="comment">// 数字提取某一位的技巧</span></span><br><span class="line">				help[--cnts[(arr[i] / offset) % BASE]] = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				arr[i] = help[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二分-1"><a href="#二分-1" class="headerlink" title="二分"></a>二分</h3><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><p><strong>左程云006</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>l、r 为区间左右端点，比较值为 target t（寻找 t）。需保证数组有序，若 ＞（m 为区间中点），则向右二分；若 ＜，则向左二分。当 <em>l</em>≥<em>r</em> 时结束，时间复杂度 <em>O</em>(log<em>n</em>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == target) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target) l = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二分答案-1"><a href="#二分答案-1" class="headerlink" title="二分答案"></a>二分答案</h4><p>左程云051 <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>一只会code的小金鱼  <a target="_blank" rel="noopener" href="https://b23.tv/vFaRbc9">https://b23.tv/vFaRbc9</a></p>
<p>写函数f，f函数作用为得到一个过程的答案，二分从最极限的最大可能到最小可能答案。我们则可以同f判断能否达到题目的需求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) sum += x / b[i] * a[i];</span><br><span class="line">    <span class="keyword">return</span> sum &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binaryAnswer</span><span class="params">(<span class="type">int</span> n, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(m, n, a, b)) &#123; ans = m; r = m - <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">例</span><br><span class="line"></span><br><span class="line">n台打印机，每台打印机的效率分别是a张b秒。</span><br><span class="line"></span><br><span class="line">问打印到第n张纸是多少秒</span><br><span class="line"></span><br><span class="line">设打印第n张纸x秒</span><br><span class="line"></span><br><span class="line">f函数可以求出x秒时具体可以打印多少张纸</span><br><span class="line"></span><br><span class="line">x/b*a和n张比，够了记答案往左二分，不够则不记答案往右二分，最大给<span class="number">1e9</span></span><br></pre></td></tr></table></figure>



<h3 id="高精度-1"><a href="#高精度-1" class="headerlink" title="高精度"></a>高精度</h3><p>（用数组模拟 列竖式计算）</p>
<p>麦克老师讲算法 高精度算法全套  <a target="_blank" rel="noopener" href="https://b23.tv/sArWoTg">https://b23.tv/sArWoTg</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/bignum/">高精度计算 - OI Wiki</a></p>
<h4 id="高精度加法-1"><a href="#高精度加法-1" class="headerlink" title="高精度加法"></a>高精度加法</h4><p>处理两个大整数相加，用数组存储每一位，模拟进位操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>, i = num<span class="number">1.</span><span class="built_in">size</span>() - <span class="number">1</span>, j = num<span class="number">2.</span><span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="type">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) sum += num1[i--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) sum += num2[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(sum % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="高精度减法-1"><a href="#高精度减法-1" class="headerlink" title="高精度减法"></a>高精度减法</h4><p>处理两个大整数相减，用数组存储每一位，模拟借位操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">subtract</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 &lt; num2) <span class="keyword">return</span> <span class="string">&quot;-&quot;</span> + <span class="built_in">subtract</span>(num2, num1);</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> borrow = <span class="number">0</span>, i = num<span class="number">1.</span><span class="built_in">size</span>() - <span class="number">1</span>, j = num<span class="number">2.</span><span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> diff = (num1[i] - <span class="string">&#x27;0&#x27;</span>) - borrow;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) diff -= (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123; diff += <span class="number">10</span>; borrow = <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> borrow = <span class="number">0</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(diff + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        i--; j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除前导零</span></span><br><span class="line">    <span class="keyword">while</span> (res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.<span class="built_in">back</span>() == <span class="string">&#x27;0&#x27;</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="前缀和与差分-1"><a href="#前缀和与差分-1" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45629285/article/details/111146240?sharetype=blog&shareId=111146240&sharerefer=APP&sharesource=2401_87034440&sharefrom=link">https://blog.csdn.net/weixin_45629285/article/details/111146240?sharetype=blog&amp;shareId=111146240&amp;sharerefer=APP&amp;sharesource=2401_87034440&amp;sharefrom=link</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/basic/prefix-sum/">前缀和 &amp; 差分 - OI Wiki</a></p>
<h4 id="一维前缀和-1"><a href="#一维前缀和-1" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><p>作用，可以快速求出区间l 到 r之间数之和。</p>
<p>只需要执行 <code>sum[r] - sum[l - 1]</code>。输出原序列中从第<code>l</code>个数到第r个数的和的时间复杂度变成了<code>O(1)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefixSum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询区间[l,r]的和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; sum, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[r + <span class="number">1</span>] - sum[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二维前缀和-1"><a href="#二维前缀和-1" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p><strong>二维前缀和预处理公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span> ] + a[i] [j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>以<code>(x1, y1)</code>为左上角，<code>(x2, y2)</code>为右下角的子矩阵的和为：<br><code>s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">prefixSum2D</span>(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询子矩阵(x1,y1)-(x2,y2)的和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query2D</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; s, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="一维差分-1"><a href="#一维差分-1" class="headerlink" title="一维差分"></a>一维差分</h4><p><strong>结论</strong>：给<code>a</code>数组中的<code>[ l, r] </code>区间中的每一个数都加上<code>c</code>,</p>
<p>只需对差分数组<code>b</code>做 <code>b[l] + = c</code>, <code>b[r+1] - = c </code>。</p>
<p>构造差分数组，差分为前缀和的逆运算。可以做到快速为数组中的每个值进行加减运算。</p>
<h4 id="二维差分-1"><a href="#二维差分-1" class="headerlink" title="二维差分"></a>二维差分</h4><p>(思路同一维)</p>
<p>构造方法，<strong>结论</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[i][j] = a[i][j] − a[i − 1][j] − a[i][j − 1] + a[i − 1 ][j − 1]</span><br></pre></td></tr></table></figure>



<h3 id="双指针算法-1"><a href="#双指针算法-1" class="headerlink" title="双指针算法"></a>双指针算法</h3><p><strong>左程云050</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>1有的双指针知识单纯用到两个指针</p>
<p>2有的则包含单调性（贪心）方面的思考与分析</p>
<p>常见类型：1）同向双指针 2）快慢双指针 3）从两端向中间的双指针</p>
<h3 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h3><p><strong>左程云003 031 033</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>直接操作二进制位，用于高效计算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOdd</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &amp; <span class="number">1</span>; &#125; <span class="comment">// 判断奇偶</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &amp; -n; &#125; <span class="comment">// 获取最低位1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOnes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">// 计算二进制中1的个数</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>; <span class="comment">// 清除最低位1</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="位图-1"><a href="#位图-1" class="headerlink" title="位图"></a>位图</h3><p><strong>左程云032</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>用bit组成数组存放值，用bit01代表存在与否，取存用位运算。</p>
<p>限制 必须连续范围，不能过大。</p>
<p>优点 极大的节省空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitset</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; set;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bitset</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        set.<span class="built_in">resize</span>((n + <span class="number">31</span>) / <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = num / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> bitPos = num % <span class="number">32</span>;</span><br><span class="line">        set[index] |= (<span class="number">1</span> &lt;&lt; bitPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = num / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> bitPos = num % <span class="number">32</span>;</span><br><span class="line">        set[index] &amp;= ~(<span class="number">1</span> &lt;&lt; bitPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = num / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> bitPos = num % <span class="number">32</span>;</span><br><span class="line">        set[index] ^= (<span class="number">1</span> &lt;&lt; bitPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = num / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> bitPos = num % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> ((set[index] &gt;&gt; bitPos) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="离散化-1"><a href="#离散化-1" class="headerlink" title="离散化"></a>离散化</h3><p><strong>左程云048</strong></p>
<p>【算法讲解048【必备】二维前缀和、二维差分、离散化技巧】</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Wz4y1K74C?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Wz4y1K74C?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>将无限或大范围的数值映射到有限、连续的整数区间，保留相对大小关系，用于优化数据范围过大的问题（如坐标压缩、频率统计）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 离散化单个值x（tmp为排序去重后的数组）</span></span><br><span class="line"><span class="type">int</span> idx = <span class="built_in">lower_bound</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), x) - tmp.<span class="built_in">begin</span>();</span><br><span class="line">lower_bound 返回第一个≥当前值的位置，保证相同值映射到同一下标</span><br><span class="line">    </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">discretize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp = nums;</span><br><span class="line">    <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">    tmp.<span class="built_in">erase</span>(<span class="built_in">unique</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>()), tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        x = <span class="built_in">lower_bound</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), x) - tmp.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="区间合并-1"><a href="#区间合并-1" class="headerlink" title="区间合并"></a>区间合并</h3><p>合并重叠区间，先按左端点排序，再遍历合并。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merged;</span><br><span class="line">    merged.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interval[<span class="number">0</span>] &lt;= merged.<span class="built_in">back</span>()[<span class="number">1</span>])</span><br><span class="line">            merged.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(merged.<span class="built_in">back</span>()[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            merged.<span class="built_in">push_back</span>(interval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>【【强烈推荐】深入浅出数据结构 - 顶尖程序员图文讲解 - UP主翻译校对 (已完结)】</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fv4y1f7T1?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Fv4y1f7T1?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<h4 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><strong>存储特点</strong>：</p>
<p>使用二维数组 <code>g[i][j]</code> 表示顶点 <code>i</code> 到 <code>j</code> 的连接关系</p>
<p>无向图的矩阵是对称的，有向图可能不对称</p>
<p>矩阵中 <code>1</code> 表示有边，<code>0</code> 或 <code>∞</code> 表示无边（带权图存储权重值）</p>
<p><strong>优点</strong>：</p>
<ol>
<li>实现简单，支持快速查询任意两顶点间是否有边（O (1)）</li>
<li>便于计算每个顶点的度（行 &#x2F; 列和）</li>
<li>适合稠密图（边数接近顶点数平方）</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>空间复杂度高（O (V²)），存储稀疏图时浪费大量空间（V：顶点vertex E：边edge）</li>
<li>添加 &#x2F; 删除顶点需重新调整矩阵大小，效率低</li>
<li>统计边的总数需要遍历整个矩阵（O (V²)）</li>
</ol>
<h4 id="链表与邻接表-1"><a href="#链表与邻接表-1" class="headerlink" title="链表与邻接表"></a>链表与邻接表</h4><p><strong>优点</strong>：</p>
<ol>
<li>空间效率高（O (V+E)），适合稀疏图（边数远小于顶点数平方）</li>
<li>便于添加 &#x2F; 删除顶点和边</li>
<li>遍历所有边的时间复杂度为 O (E)</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>判断两顶点间是否有边效率较低（O (degree (v))）</li>
<li>计算顶点的度需遍历对应链表（O (degree (v))）</li>
<li>不适合频繁查询任意两顶点间的关系</li>
</ol>
<h4 id="栈与队列-1"><a href="#栈与队列-1" class="headerlink" title="栈与队列"></a>栈与队列</h4><h5 id="最小栈（O-1-获取最小值）-1"><a href="#最小栈（O-1-获取最小值）-1" class="headerlink" title="最小栈（O (1) 获取最小值）"></a>最小栈（O (1) 获取最小值）</h5><p><strong>左程云015</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15X4y177cM?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV15X4y177cM?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>维护一个最小栈minval包含getmin功能   若入栈元素x小于等于最小栈的栈顶则x入最小栈</p>
<p>minVal.empty() || x &lt;&#x3D; minVal.top()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; data, minVal;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (minVal.<span class="built_in">empty</span>() || x &lt;= minVal.<span class="built_in">top</span>())</span><br><span class="line">            minVal.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">top</span>() == minVal.<span class="built_in">top</span>())</span><br><span class="line">            minVal.<span class="built_in">pop</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> minVal.<span class="built_in">top</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="单调栈（下一个更大元素）-1"><a href="#单调栈（下一个更大元素）-1" class="headerlink" title="单调栈（下一个更大元素）"></a>单调栈（下一个更大元素）</h5><p>实现原理：以单调递增栈为例，当新元素入栈时，会将栈中所有比它大的元素弹出，直到栈为空或者栈顶元素小于等于新元素，然后将新元素入栈。单调递减栈则相反。</p>
<p>遍历每个元素时，将当前元素与栈顶元素比较：</p>
<p>若当前元素<strong>小于等于</strong>栈顶元素 → 直接入栈，保持栈的递增性</p>
<p>若当前元素大于栈顶元素 → 触发以下操作：</p>
<ol>
<li><strong>弹出栈顶元素</strong>，并记录当前元素为其「下一个更大值」</li>
<li><strong>持续弹出</strong>新的栈顶元素，直到当前元素 ≤ 栈顶</li>
<li><strong>当前元素入栈</strong>，恢复栈的递增顺序</li>
</ol>
<p>这个过程中，每个元素被弹出时，其「下一个更大值」即为触发弹出的当前元素。遍历结束后，栈内剩余元素的「下一个更大值」均为默认值（如 - 1 或无穷大）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            res[st.<span class="built_in">top</span>()] = nums[i];</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="单调队列（滑动窗口最大值）-1"><a href="#单调队列（滑动窗口最大值）-1" class="headerlink" title="单调队列（滑动窗口最大值）"></a>单调队列（滑动窗口最大值）</h5><p>实现原理：通常用双端队列来实现。以单调递增队列为例，当新元素要入队时，从队尾开始比较，如果队尾元素大于新元素，则将队尾元素出队，直到队尾元素小于等于新元素或者队列为空，然后将新元素从队尾入队。在进行出队操作时，如果队首元素超出了当前考虑的范围，则将队首元素出队。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 移除队尾较小元素</span></span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 移除窗口外元素</span></span><br><span class="line">        <span class="keyword">if</span> (dq.<span class="built_in">front</span>() &lt;= i - k)</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="KMP-算法以及find-字符串匹配-1"><a href="#KMP-算法以及find-字符串匹配-1" class="headerlink" title="KMP 算法以及find()字符串匹配"></a>KMP 算法以及find()字符串匹配</h4><p><strong>左程云100</strong> 、<strong>101</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>核心思想：利用已经匹配过的部分信息，避免不必要的字符比较，从而提高匹配效率。</p>
<p>通过预处理模式串的 next 数组，记录模式串中每个位置之前最长的相同前缀和后缀长度。</p>
<p><strong>Next 数组含义</strong>：<br><code>next[i]</code> 表示模式串 <code>pattern[0..i]</code> 的<strong>最长公共前后缀长度</strong>。<br>例如：<code>pattern = &quot;ababc&quot;</code>，其 <code>next</code> 数组为 <code>[0, 0, 1, 2, 0]</code>。</p>
<p><strong>匹配过程优化</strong>：<br>当主串 <code>S[i]</code> 与模式串 <code>P[j]</code> 不匹配时，直接将 <code>j</code> 回退到 <code>next[j-1]</code>，而<strong>主串指针 <code>i</code> 不回退</strong>。</p>
<p><strong>总结</strong>：KMP 通过预处理模式串，记录每个位置的最长公共前后缀长度，在匹配失败时快速回退模式串指针，避免主串重复扫描。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;hello world, world!&quot;</span>;</span><br><span class="line">    string substr = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    string charset = <span class="string">&quot;aeiou&quot;</span>;</span><br><span class="line">    string digits = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">    <span class="comment">// 1. 基本查找：find() 和 rfind()</span></span><br><span class="line">    <span class="type">size_t</span> pos1 = str.<span class="built_in">find</span>(substr);            <span class="comment">// 正向查找子串，返回6</span></span><br><span class="line">    <span class="type">size_t</span> pos2 = str.<span class="built_in">find</span>(substr, <span class="number">7</span>);         <span class="comment">// 从位置7开始查找，返回13</span></span><br><span class="line">    <span class="type">size_t</span> pos3 = str.<span class="built_in">rfind</span>(substr);           <span class="comment">// 反向查找子串，返回13</span></span><br><span class="line">    <span class="type">size_t</span> pos4 = str.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>);               <span class="comment">// 查找字符，返回4</span></span><br><span class="line">    <span class="type">size_t</span> pos5 = str.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">5</span>);            <span class="comment">// 从位置5开始查找字符，返回7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查找任意字符：find_first_of() 和 find_last_of()</span></span><br><span class="line">    <span class="type">size_t</span> pos6 = str.<span class="built_in">find_first_of</span>(charset);  <span class="comment">// 查找首个元音字母，返回1(&#x27;e&#x27;)</span></span><br><span class="line">    <span class="type">size_t</span> pos7 = str.<span class="built_in">find_last_of</span>(charset);   <span class="comment">// 查找最后一个元音字母，返回11(&#x27;o&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查找非指定字符：find_first_not_of() 和 find_last_not_of()</span></span><br><span class="line">    string spaces = <span class="string">&quot;   abc   &quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> pos8 = spaces.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>); <span class="comment">// 查找首个非空格字符，返回3(&#x27;a&#x27;)</span></span><br><span class="line">    <span class="type">size_t</span> pos9 = spaces.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);  <span class="comment">// 查找最后一个非空格字符，返回5(&#x27;c&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 遍历所有匹配位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有 &#x27;world&#x27; 的位置：&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> currentPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((currentPos = str.<span class="built_in">find</span>(substr, currentPos)) != string::npos) &#123;</span><br><span class="line">        cout &lt;&lt; currentPos &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        currentPos += substr.<span class="built_in">length</span>(); <span class="comment">// 跳过已匹配的部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">// 输出: 6 13</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 检查字符串是否包含子串</span></span><br><span class="line">    <span class="type">bool</span> hasWorld = (str.<span class="built_in">find</span>(substr) != string::npos); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 处理未找到的情况</span></span><br><span class="line">    <span class="type">size_t</span> notFound = str.<span class="built_in">find</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (notFound == string::npos) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#x27;xyz&#x27; 未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 特殊情况：空字符串查找</span></span><br><span class="line">    <span class="type">size_t</span> emptyPos = str.<span class="built_in">find</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 始终返回0（空字符串被视为存在于字符串开头）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 查找首个非数字字符</span></span><br><span class="line">    string numStr = <span class="string">&quot;123.45&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> dotPos = numStr.<span class="built_in">find_first_not_of</span>(digits); <span class="comment">// 返回3(&#x27;.&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出所有结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos1: &quot;</span> &lt;&lt; pos1 &lt;&lt; endl; <span class="comment">// 6</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos2: &quot;</span> &lt;&lt; pos2 &lt;&lt; endl; <span class="comment">// 13</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos3: &quot;</span> &lt;&lt; pos3 &lt;&lt; endl; <span class="comment">// 13</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos4: &quot;</span> &lt;&lt; pos4 &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos5: &quot;</span> &lt;&lt; pos5 &lt;&lt; endl; <span class="comment">// 7</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos6: &quot;</span> &lt;&lt; pos6 &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos7: &quot;</span> &lt;&lt; pos7 &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos8: &quot;</span> &lt;&lt; pos8 &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos9: &quot;</span> &lt;&lt; pos9 &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hasWorld: &quot;</span> &lt;&lt; (hasWorld ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl; <span class="comment">// true</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dotPos: &quot;</span> &lt;&lt; dotPos &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Trie-树（字典树）-1"><a href="#Trie-树（字典树）-1" class="headerlink" title="Trie 树（字典树）"></a>Trie 树（字典树）</h4><p><strong>左程云044</strong> <strong>045</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>Trie 树通过共享字符串前缀存储多组单词，使查询效率仅取决于字符串长度，适合高频前缀匹配场景。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    vector&lt;TrieNode*&gt; children;  <span class="comment">// 子节点数组（假设仅包含小写字母）</span></span><br><span class="line">    <span class="type">bool</span> isEndOfWord;            <span class="comment">// 标记是否为单词结尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">children</span>(<span class="number">26</span>, <span class="literal">nullptr</span>), <span class="built_in">isEndOfWord</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123; root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[idx]) &#123;</span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEndOfWord = <span class="literal">true</span>;  <span class="comment">// 标记单词结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找字符串</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找前缀</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 辅助函数：查找前缀路径</span></span><br><span class="line">    <span class="function">TrieNode* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[idx]) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="并查集（合并查询集合）-1"><a href="#并查集（合并查询集合）-1" class="headerlink" title="并查集（合并查询集合）"></a>并查集（合并查询集合）</h4><p><strong>蓝不过海呀</strong> </p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zZRSYUEWV?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1zZRSYUEWV?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p><strong>麦克老师讲算法</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jv411a7LK?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1jv411a7LK?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>合并 查询 集合</p>
<p>用数组 保存每个节点的父亲</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        p[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rootx = <span class="built_in">Find</span>(x);</span><br><span class="line">    <span class="type">int</span> rooty = <span class="built_in">Find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(rootx!=rooty)&#123;<span class="comment">//按大小合并</span></span><br><span class="line">        <span class="keyword">if</span>(p[rootx]&lt;p[rooty])&#123;</span><br><span class="line">            p[rooty]=rootx;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[rootx]&gt;p[rooty])&#123;</span><br><span class="line">            p[rootx]=rooty;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[rootx]=rooty;</span><br><span class="line">            p[rooty]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rootx!=rooty)&#123;<span class="comment">//按照高度合并</span></span><br><span class="line">        <span class="keyword">if</span>(p[rootx]&lt;p[rooty])&#123;</span><br><span class="line">            p[rootx]+=p[rooty];</span><br><span class="line">            p[rooty]=rootx;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p[rooty]+=p[rootx];</span><br><span class="line">            p[rootx]=rooty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find</span>(p[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆（优先队列）-1"><a href="#堆（优先队列）-1" class="headerlink" title="堆（优先队列）"></a>堆（优先队列）</h4><p><strong>高效维护和获取极值（最大值或最小值）</strong>，并支持快速插入、删除操作。一般使用stl库中函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br></pre></td></tr></table></figure>

<h4 id="Hash-表（两数之和）-1"><a href="#Hash-表（两数之和）-1" class="headerlink" title="Hash 表（两数之和）"></a>Hash 表（两数之和）</h4><p><strong>左程云026</strong> <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p>作用为快速查找 &#x2F; 统计</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13m4y1p7VB?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV13m4y1p7VB?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p><strong>只用存元素</strong>  <code>unordered_set</code>      <strong>需要存元素 + 额外信息</strong>  <code>unordered_map</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="comment">/*去重 / 判重	unordered_set	自动去重，仅需检查元素存在性（如判断数组是否有重复元素）。</span></span><br><span class="line"><span class="comment">统计频率 / 映射关系	unordered_map	需要存储键值对（如统计字符出现次数、记录节点距离）。</span></span><br><span class="line"><span class="comment">缓存中间结果	unordered_map	需要同时存储输入和计算结果（如记忆化搜索）。</span></span><br><span class="line"><span class="comment">快速查找补数 / 配对	unordered_map	需要键值对关联（如两数之和问题，需快速查找目标值的补数）。*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x, y; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PH</span> &#123; <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.x ^ p.y; <span class="comment">// 简化哈希函数</span></span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基础用法</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">4</span>);        <span class="comment">// 插入</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">2</span>);         <span class="comment">// 删除</span></span><br><span class="line">    <span class="type">bool</span> exists = s.<span class="built_in">count</span>(<span class="number">3</span>); <span class="comment">// 存在检查</span></span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">find</span>(<span class="number">1</span>); <span class="comment">// 迭代器查找</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义类型</span></span><br><span class="line">    unordered_set&lt;Point, PH&gt; points;</span><br><span class="line">    points.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : s) &#123; <span class="comment">/* 使用e */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="搜索与图论-1"><a href="#搜索与图论-1" class="headerlink" title="搜索与图论"></a>搜索与图论</h3><h4 id="DFS-与-BFS-1"><a href="#DFS-与-BFS-1" class="headerlink" title="DFS 与 BFS"></a>DFS 与 BFS</h4><h5 id="DFS（深度优先搜索）-1"><a href="#DFS（深度优先搜索）-1" class="headerlink" title="DFS（深度优先搜索）"></a>DFS（深度优先搜索）</h5><p><strong>一只会code的小金鱼</strong>  <a target="_blank" rel="noopener" href="https://b23.tv/vFaRbc9">https://b23.tv/vFaRbc9</a></p>
<p>排列，指数级 深入探索分支至无法继续，然后回溯后探索其他分支。核心在于递归</p>
<p>DFS适合此类题目：给定初始状态跟目标状态，要求判断从初始状态到目标状态是否有解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, <span class="type">int</span> u, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : adj[u])</span><br><span class="line">        <span class="keyword">if</span> (!visited[v])</span><br><span class="line">            <span class="built_in">dfs</span>(adj, v, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS（广度优先搜索）-1"><a href="#BFS（广度优先搜索）-1" class="headerlink" title="BFS（广度优先搜索）"></a>BFS（广度优先搜索）</h5><p>**左程云062  ** <a target="_blank" rel="noopener" href="https://b23.tv/biO1uQB">https://b23.tv/biO1uQB</a></p>
<p><strong>一只会code的小金鱼</strong> <a target="_blank" rel="noopener" href="https://b23.tv/vFaRbc9">https://b23.tv/vFaRbc9</a></p>
<p>队列，逐层扩散，扩散几层最短路就是多少，可以单点弹出，整层弹出。标记状态数组，剪枝。</p>
<p>使用要求：任意两相邻节点距离等同(边权相同)。</p>
<p>二段性：一边全符合，另一边全不符合，且队列内最多两种状态。x和x+1。</p>
<p>bfs队列具有的性质：单调性 单调增减</p>
<h5 id="多源bfs-1"><a href="#多源bfs-1" class="headerlink" title="多源bfs"></a>多源bfs</h5><p>提前把源头存入队列(有个虚拟的源点连接多个边权为0的点(多个源头))。</p>
<h5 id="01bfs-1"><a href="#01bfs-1" class="headerlink" title="01bfs"></a>01bfs</h5><p>双端队列 队头入队or队尾入队</p>
<h5 id="双向bfs-1"><a href="#双向bfs-1" class="headerlink" title="双向bfs"></a>双向bfs</h5><p><strong>左程云063</strong></p>
<p>维护两个队列，需要知道起点和终点位置，从起点和终点同时开始bfs，维护状态数组记录两个bfs到的状态，若碰上则证明可以从起点到终点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = adj.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dist[v] = dist[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="拓扑排序（有向无环图）-1"><a href="#拓扑排序（有向无环图）-1" class="headerlink" title="拓扑排序（有向无环图）"></a>拓扑排序（有向无环图）</h4><p><strong>拓扑排序</strong>是对 ** 有向无环图（DAG）** 的顶点进行排序的算法，使得对于每条有向边 (u→v)，顶点 u 在排序中均出现在 v 之前，常用 Kahn 算法（入度队列）或 DFS 实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topologicalSort</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edges : adj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : edges)</span><br><span class="line">            inDegree[v]++;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u])</span><br><span class="line">            <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">size</span>() == n ? res : <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最短路-1"><a href="#最短路-1" class="headerlink" title="最短路"></a>最短路</h4><p><strong>左程云064</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Cm4y1g77W?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Cm4y1g77W?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<h5 id="Dijkstra-算法（单源最短路径）-1"><a href="#Dijkstra-算法（单源最短路径）-1" class="headerlink" title="Dijkstra 算法（单源最短路径）"></a>Dijkstra 算法（单源最短路径）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; <span class="comment">// &#123;距离, 节点编号&#125;</span></span><br><span class="line"><span class="comment">// 输入：邻接表graph，源点src，输出：源点到各点的最短距离数组dist</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;PII&gt;&gt;&amp; graph, <span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// 初始化距离为无穷大</span></span><br><span class="line">    dist[src] = <span class="number">0</span>; <span class="comment">// 源点到自身距离为0</span></span><br><span class="line">    <span class="comment">// 最小堆（优先队列）</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, src&#125;); <span class="comment">// &#123;距离, 节点&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, u] = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过已处理的节点（避免重复计算）</span></span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有邻接边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : graph[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &gt; dist[u] + w) &#123;</span><br><span class="line">                dist[v] = dist[u] + w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// 节点数</span></span><br><span class="line">    vector&lt;vector&lt;PII&gt;&gt; <span class="built_in">graph</span>(n); <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="comment">// 添加边 (u-&gt;v 权重为w)</span></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// 0-&gt;1 权重2</span></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">4</span>&#125;); <span class="comment">// 0-&gt;2 权重4</span></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">1</span>&#125;); <span class="comment">// 1-&gt;2 权重1</span></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">7</span>&#125;); <span class="comment">// 1-&gt;3 权重7</span></span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">3</span>&#125;); <span class="comment">// 2-&gt;3 权重3</span></span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">2</span>&#125;); <span class="comment">// 3-&gt;4 权重2</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dist = <span class="built_in">dijkstra</span>(graph, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;从节点0到节点&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的最短距离是: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] == INT_MAX) cout &lt;&lt; <span class="string">&quot;INF&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="a-算法-1"><a href="#a-算法-1" class="headerlink" title="a*算法"></a>a*算法</h5><p><strong>左程云065</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1t94y187zW?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1t94y187zW?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>问从特定点到特定点的最短距离</p>
<p>与dijkstra算法distance数组相同，区别在小根堆的使用时加一个曼哈顿距离(估计一个长度，影响小根堆弹出顺序，致使运行时间缩短)</p>
<h5 id="距离-1"><a href="#距离-1" class="headerlink" title="距离"></a>距离</h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/geometry/distance/">距离 - OI Wiki</a></p>
<p><strong>欧氏距离</strong>，一般也称作欧几里得距离，空间两点间的欧氏距离为：根号下a方+b方+c方</p>
<p>缺点：两个整点计算其欧氏距离时，往往答案是浮点型，会存在一定误差。</p>
<p><strong>曼哈顿距离</strong>（Manhattan distance）</p>
<p>为它们横坐标之差的绝对值与纵坐标之差的绝对值之和。可以表示为：|x1-x2|+|y1-y2|</p>
<p>[P5098 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5098">USACO04OPEN] Cave Cows 3 - 洛谷</a></p>
<p><strong>切比雪夫距离</strong></p>
<p>是向量空间中的一种度量，二个点之间的距离定义为其各坐标数值差的最大值。</p>
<p>二维中表示为：max(|x1-x2|,|y1-y2|)</p>
<p>如果将曼哈顿距离转换成切比雪夫距离</p>
<p>那么圆形的辐射范围变成了一个矩形，可以用O(n²)扫描线，扫描圆形辐射范围</p>
<h5 id="Floyd-算法（多源最短路径）-1"><a href="#Floyd-算法（多源最短路径）-1" class="headerlink" title="Floyd 算法（多源最短路径）"></a>Floyd 算法（多源最短路径）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dist)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = dist.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最小生成树-1"><a href="#最小生成树-1" class="headerlink" title="最小生成树"></a>最小生成树</h4><p><strong>左程云061</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sK4y1F7LH?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1sK4y1F7LH?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>包含Kruskal prim及其优化</p>
<h3 id="数学知识-1"><a href="#数学知识-1" class="headerlink" title="数学知识"></a>数学知识</h3><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/number-theory/sieve/">筛法 - OI Wiki</a></p>
<h4 id="素数筛-1"><a href="#素数筛-1" class="headerlink" title="素数筛"></a>素数筛</h4><p>思路 ：对于任意一个大于1  的正整数 ，那么它的 x倍就是合数（x&gt;1）。利用这个结论，我们可以避免很多次不必要的检测。</p>
<p>如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。</p>
<p>这种 <strong>线性筛法</strong> 也称为 <strong>Euler 筛法</strong>（欧拉筛法）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; pri;</span><br><span class="line"><span class="type">bool</span> not_prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!not_prime[i]) &#123;</span><br><span class="line">      pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pri_j : pri) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * pri_j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">      not_prime[i * pri_j] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri_j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// i % pri_j == 0</span></span><br><span class="line">        <span class="comment">// 换言之，i 之前被 pri_j 筛过了</span></span><br><span class="line">        <span class="comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被</span></span><br><span class="line">        <span class="comment">// pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break</span></span><br><span class="line">        <span class="comment">// 掉就好了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="欧拉函数（φ-n-）-1"><a href="#欧拉函数（φ-n-）-1" class="headerlink" title="欧拉函数（φ(n)）"></a>欧拉函数（φ(n)）</h4><p>计算小于等于 n 且与 n 互质的数的个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; pri;</span><br><span class="line"><span class="type">bool</span> not_prime[N];</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!not_prime[i]) &#123;</span><br><span class="line">      pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">      phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pri_j : pri) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * pri_j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">      not_prime[i * pri_j] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri_j == <span class="number">0</span>) &#123;</span><br><span class="line">        phi[i * pri_j] = phi[i] * pri_j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      phi[i * pri_j] = phi[i] * phi[pri_j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速幂-1"><a href="#快速幂-1" class="headerlink" title="快速幂"></a>快速幂</h4><p><strong>左程云098</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13k4y1D7Dn?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV13k4y1D7Dn?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>计算 a*b mod <em>m</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fastPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a % m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="矩阵快速幂-1"><a href="#矩阵快速幂-1" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><p>返回mat^power % mod</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix_pow</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat, <span class="type">int</span> power, <span class="type">int</span> mod) &#123;</span><br><span class="line"><span class="type">int</span> n = mat.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单位矩阵</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (power % <span class="number">2</span> == <span class="number">1</span>) res = <span class="built_in">multiply</span>(res, mat, mod);</span><br><span class="line"></span><br><span class="line">    mat = <span class="built_in">multiply</span>(mat, mat, mod);</span><br><span class="line"></span><br><span class="line">    power /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最大公约数（GCD）-1"><a href="#最大公约数（GCD）-1" class="headerlink" title="最大公约数（GCD）"></a>最大公约数（GCD）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小公倍数（LCM）-1"><a href="#最小公倍数（LCM）-1" class="headerlink" title="最小公倍数（LCM）"></a>最小公倍数（LCM）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>左程云</strong>066——088</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ww41167Ac?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1Ww41167Ac?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p><strong>一只会code的小金鱼</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1r84y1379W?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1r84y1379W?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>给定一个问题，拆分为一个个子问题，直到子问题得到解决。保存子问题答案以减少重复计算。(记忆化搜索)再根据子问题答案反推，得到原问题解。</p>
<p>动态规划是递推的子集？</p>
<p>例题:跳台阶  一个楼梯n级台阶，每次走一或两级，问从0到n有多少种方案。</p>
<p>记忆化搜索(dfs+记录答案)想实现记忆化搜索，dfs的参数应该尽可能少，不应该传入不影响边界的参数。</p>
<p>剪枝则应该尽可能把能剪枝的参数传入保留</p>
<p>递归 递分解问题 自顶向下，归得到答案 自底向上。只进行归可不可以？从下逐层往上推</p>
<p>递推公式(dfs向下递归公式)</p>
<p>线性dp 例洛谷u224502</p>
<p>阿福是经验丰富大盗，要洗劫有N家店铺的一条街，每家店有现金。</p>
<p>已知同时洗劫相邻店铺报警系统会启动，阿福不想被抓，给定T组数据，每组数据先给店铺数N，再给N家店铺现金数，求每组数据下 阿福在不惊动警察时最多能得的现金数。</p>
<h3 id="贪心算法-1"><a href="#贪心算法-1" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><strong>左程云</strong>089——094</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1be41167yw?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1be41167yw?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p><strong>湖北工业大学</strong>ACM集训队 2025寒假培训第四讲——贪心初步</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KGcBeVEyW?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1KGcBeVEyW?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<h4 id="活动安排问题-1"><a href="#活动安排问题-1" class="headerlink" title="活动安排问题"></a>活动安排问题</h4><p>选择最多的不重叠活动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxActivities</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; activities)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(activities.<span class="built_in">begin</span>(), activities.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>, lastEnd = activities[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; activities.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activities[i][<span class="number">0</span>] &gt;= lastEnd) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            lastEnd = activities[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈夫曼编码（最小带权路径长度）-1"><a href="#哈夫曼编码（最小带权路径长度）-1" class="headerlink" title="哈夫曼编码（最小带权路径长度）"></a>哈夫曼编码（最小带权路径长度）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> freq;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> f) : <span class="built_in">freq</span>(f), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* a, Node* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;freq &gt; b-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">huffman</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; freq)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node*, vector&lt;Node*&gt;, Compare&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> f : freq)</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(f));</span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Node* a = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        Node* b = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        Node* parent = <span class="keyword">new</span> <span class="built_in">Node</span>(a-&gt;freq + b-&gt;freq);</span><br><span class="line">        parent-&gt;left = a;</span><br><span class="line">        parent-&gt;right = b;</span><br><span class="line">        pq.<span class="built_in">push</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.<span class="built_in">top</span>()-&gt;freq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="博弈类问题-1"><a href="#博弈类问题-1" class="headerlink" title="博弈类问题"></a>博弈类问题</h3><p><strong>左程云095</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1T5411i7Gg?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1T5411i7Gg?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<p>简单博弈类问题情境下，每个局面仅存在两种可能：先手必胜（后手必败）和先手必败（后手必胜）状态</p>
<p>简称为 <strong>必胜态</strong> <strong>必败态</strong></p>
<h4 id="巴什博弈（Bash-Game）-1"><a href="#巴什博弈（Bash-Game）-1" class="headerlink" title="巴什博弈（Bash Game）"></a>巴什博弈（Bash Game）</h4><p><strong>简述</strong>：两人轮流从一堆物品中取物，每次至少取 1 个，最多取<code>m</code>个，取走最后一个物品者胜。</p>
<p><strong>结论</strong>：若物品总数<code>n</code>能被<code>m+1</code>整除，则后手必胜；否则先手必胜。<br>（核心：先手可通过取<code>n mod (m+1)</code>个物品，使剩余数量为<code>m+1</code>的倍数，后续镜像后手操作即可获胜。）</p>
<h4 id="尼姆博弈（Nim-Game）-1"><a href="#尼姆博弈（Nim-Game）-1" class="headerlink" title="尼姆博弈（Nim Game）"></a>尼姆博弈（Nim Game）</h4><p><strong>简述</strong>：两人轮流从多堆物品中选一堆，取走任意数量（至少 1 个），取走最后一个物品者胜。</p>
<p><strong>结论</strong>：计算所有堆物品数量的<strong>异或和</strong>（XOR）。若异或和为 0，则后手必胜；否则先手必胜。<br>（核心：先手可通过操作使各堆数量异或和为 0，后续镜像后手操作即可获胜。）</p>
<h4 id="斐波那契博弈（Fibonacci-Game）-1"><a href="#斐波那契博弈（Fibonacci-Game）-1" class="headerlink" title="斐波那契博弈（Fibonacci Game）"></a>斐波那契博弈（Fibonacci Game）</h4><p><strong>简述</strong>：一堆物品共<code>n</code>个，两人轮流取物，先手首次取 1 到<code>n-1</code>个，之后每次取物数量不超过对手上一次取物数量的 2 倍，取走最后一个物品者胜。</p>
<p><strong>结论</strong>：若<code>n</code>是<strong>斐波那契数</strong>，则后手必胜；否则先手必胜。<br>（核心：斐波那契数构成必败态，非斐波那契数可分解为两个不连续的斐波那契数，先手通过取走较小数打破平衡。）</p>
<h4 id="威佐夫博弈（Wythoff-Game）-1"><a href="#威佐夫博弈（Wythoff-Game）-1" class="headerlink" title="威佐夫博弈（Wythoff Game）"></a>威佐夫博弈（Wythoff Game）</h4><p><strong>简述</strong>：两人轮流从两堆物品中取物，可从一堆取任意数量，或从两堆取相同数量，取走最后一个物品者胜。</p>
<p><strong>结论</strong>：设两堆数量为<code>(a, b)</code>（<code>a ≤ b</code>），计算<code>k = b - a</code>。若<code>a = ⌊k * (√5 + 1)/2⌋</code></p>
<p>（黄金分割数≈1.618），则后手必胜；否则先手必胜。</p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/game-theory/impartial-game/">公平组合游戏 - OI Wiki</a></p>
<p>图游戏概念：每个博弈局面对应图中一个点，行动对应点到后继点的边，必败局面视为无后继节点的点</p>
<h4 id="公平组合游戏（ICG）-1"><a href="#公平组合游戏（ICG）-1" class="headerlink" title="公平组合游戏（ICG）"></a>公平组合游戏（ICG）</h4><ul>
<li>可抽象为有向无环图，符合图游戏规则</li>
</ul>
<h4 id="SG-函数-1"><a href="#SG-函数-1" class="headerlink" title="SG 函数"></a>SG 函数</h4><p><strong>左程云096</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N94y1T7Mb?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c">https://www.bilibili.com/video/BV1N94y1T7Mb?vd_source=89ee9c0333eed94fc15ad7bfeda6fb8c</a></p>
<ol>
<li><p>定义</p>
<p>通过 mex（最小非负未出现整数）计算</p>
<p>必败点 SG 值 &#x3D; 0</p>
<p>非必败点 SG 值 &#x3D; 所有后继节点 SG 值的 mex</p>
</li>
<li><p>判定</p>
<p>SG≠0 → 必胜态</p>
<p>SG&#x3D;0 → 必败态</p>
</li>
</ol>
<h4 id="SG-定理（Bouton-定理）-1"><a href="#SG-定理（Bouton-定理）-1" class="headerlink" title="SG 定理（Bouton 定理）"></a>SG 定理（Bouton 定理）</h4><p>总游戏 SG 值 &#x3D; 各独立子游戏 SG 值的异或和，适用所有 ICG 游戏。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">这份笔记的记录大抵始于<span class="number">2024</span>年<span class="number">10</span>月，历经大一一整个学年的积累，最终于大一期末考试周、<span class="number">2025</span>年<span class="number">7</span>月<span class="number">7</span>日开始系统性整理与总结并最终于<span class="number">7</span>月<span class="number">9</span>日整理完毕。</span><br><span class="line">它不仅是对算法基础知识的梳理，更是我对大一学年算法学习的系统性回顾。</span><br><span class="line"><span class="number">9</span>月踏入校园时，心中既有对未知的憧憬，也藏着对方向的迷茫。</span><br><span class="line">而选择学习算法、参与竞赛，让我在自由且个人时间充裕的大学环境里找到了些许的目标，也在一次次调试代码，找到了coding的乐趣。</span><br><span class="line">更珍贵的是，这条路上总会遇见同样为一道题熬红双眼、为一个思路击掌欢呼的伙伴——他们既是并肩作战的队友，</span><br><span class="line">也是彼此较劲的对手，这种良性的竞争氛围，远比独自摸索更能推着人往前。（everybody is important）</span><br><span class="line">如果很不幸，你感到了独自学习的些许孤单，也希望你能享受独自coding的寂寞，能有举杯邀明月，对影成三人的乐观。</span><br><span class="line">算法学习当然不是坦途，但抓住初学时的冲劲，耐下心听课、细心做题至关重要。</span><br><span class="line">借着这股冲劲取得的成就，可以形成良好的正反馈，作为你日后迷茫时后盾与明灯。</span><br><span class="line">我认为，学习的三个关键是学习、思考、实践。</span><br><span class="line">学习是地基，也就是听课，需要耐心学习理论知识，理解算法的背后逻辑。</span><br><span class="line">同时很重要的一点是，sort函数可以轻松排序，并不意味着学习冒泡排序无用，</span><br><span class="line">更不意味着学习多种排序方法无用，那些前人们宝贵的经验方法可以拓宽你的思路与视野，</span><br><span class="line">也会起到触类旁通，他山之石可以攻玉的效果。</span><br><span class="line">思考是桥梁，学而不思则会陷入机械记忆和理论与实践脱离的困境，</span><br><span class="line">只有带着带着举一反三疑问去沉下心思考，才能真正理解“所以然”；</span><br><span class="line">实践是终点，也是新的起点。正如“实践是检验真理的唯一标准”，只有在深入思考后亲手写出ac的代码，</span><br><span class="line">看着自己的思路用代码实现，才算真正把课程中的知识内化成自己的东西。</span><br><span class="line">我想说，遭遇挫折与失败实属常态：或许是一道难题百思不解其意，或许是比赛中因细微疏漏导致满盘皆输，</span><br><span class="line">又或许是投入大量精力却收效甚微。如果说问题不出于内，那也只能说尽人事，听天命</span><br><span class="line">but the rain will stop the sky will clear up,nothing will be terrible forever. </span><br><span class="line">（雨会过，天会晴，事情不会一直这么糟的）</span><br><span class="line">但真正值得思考的，正如肖恩医生所言——拒绝承认失败，并从失败中汲取教训。</span><br><span class="line">面对挫折与失败，关键在于沉下心来完成发现问题、分析问题、解决问题的过程。</span><br><span class="line">如此，失败方能转化为进阶的阶梯，助力你我前行。</span><br><span class="line">最后，还有很多想写的但不知从何写起，那就到这结束吧。</span><br><span class="line">May the road rise up to meet you. （愿你我前路坦荡，一帆风顺）</span><br></pre></td></tr></table></figure>

<p>​																																		  记于2025年7月9日凌晨2时59分</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>mohan</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2025/07/08/algorithm/">http://example.com/2025/07/08/algorithm/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/07/14/%E7%9B%AE%E6%A0%87%E6%98%AF%E6%AF%92%E5%A5%B6%E7%89%A7%E9%AB%98%E6%89%8B/">目标是毒奶牧高手</a>
            
            
            <a class="next" rel="next" href="/2025/07/06/hello-world/">Hello World</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© mohan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>