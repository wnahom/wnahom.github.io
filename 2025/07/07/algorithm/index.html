<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="mohan">





<title>algorithm | nahom&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">nahom&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">nahom&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">algorithm</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">mohan</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 7, 2025&nbsp;&nbsp;22:19:17</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>最小栈</p>
<p><img src="https://com.miui.notes/note_image/34843daafcb1978fc5624020e993d447d1bda2cb"></p>
<p>补充：data min 都为空时同步压值</p>
<p>单调栈和单调队列是在算法中常用的数据结构，以下是它们的实现原理：</p>
<p>单调栈</p>
<p>实现原理：以单调递增栈为例，当新元素入栈时，会将栈中所有比它大的元素弹出，直到栈为空或者栈顶元素小于等于新元素，然后将新元素入栈。单调递减栈则相反。</p>
<p>单调队列</p>
<p>实现原理：通常用双端队列来实现。以单调递增队列为例，当新元素要入队时，从队尾开始比较，如果队尾元素大于新元素，则将队尾元素出队，直到队尾元素小于等于新元素或者队列为空，然后将新元素从队尾入队。在进行出队操作时，如果队首元素超出了当前考虑的范围，则将队首元素出队。</p>
<p>前缀和</p>
<p>一维<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45629285/article/details/111146240?sharetype=blog&shareId=111146240&sharerefer=APP&sharesource=2401_87034440&sharefrom=link">https://blog.csdn.net/weixin_45629285/article/details/111146240?sharetype=blog&amp;shareId=111146240&amp;sharerefer=APP&amp;sharesource=2401_87034440&amp;sharefrom=link</a></p>
<p>作用，可以快速求出区间l 到 r之间数之和</p>
<p>做预处理，定义一个sum[]数组，sum[i]代表a数组中前i个数的和。则sum[r] - sum[l - 1]即为答案。</p>
<p>二维</p>
<p>同一维前缀和一样，我们先来定义一个二维数组s[][] , s[i][j] 表示二维数组中，左上角(1, 1)到右下角(i, j)所包围的矩阵元素的和。</p>
<p><img src="https://com.miui.notes/note_image/a4ebfc3b8decfa71f0ee136931f8440ea4e21cff"></p>
<p>最终结论</p>
<p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</p>
<p>s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] +</p>
<p> s[x1 - 1, y1 - 1]</p>
<p>差分</p>
<p>构造差分数组，差分为前缀和的逆运算。可以做到快速为数组中的每个值进行加减运算。</p>
<p><img src="https://com.miui.notes/note_image/e429a5fcc0c9a3ce282922a3c224eeddf08bc041"></p>
<p><img src="https://com.miui.notes/note_image/504d503016d47edbc63247f7abc1c99a3606cbb6"></p>
<p>二维公式如下(思路同一维)：</p>
<p>b[i][j] &#x3D; a[i][j] − a[i − 1][j] − a[i][j − 1] + </p>
<p>a[i −1 ][j − 1]</p>
<p>二分</p>
<p>l r  比较值target t（寻找t）</p>
<p>sort保证数组有序，t＞m，记答案往右二分，＜m往左二分。l＞&#x3D;r结束，比对是否找到array中的t。</p>
<p>时间复杂度O（logn）</p>
<p>二分答案</p>
<p>写函数f，f函数作用为得到一个过程的答案，二分从最极限的最大可能到最小可能答案。我们则可以同f判断能否达到题目的需求。</p>
<p>例</p>
<p>n台打印机，每台打印机的效率分别是a张b秒。</p>
<p>问打印到第n张纸是多少秒</p>
<p>设打印第n张纸x秒</p>
<p>f函数可以求出x秒时具体可以打印多少张纸</p>
<p>x&#x2F;b*a和n张比，够了记答案往左二分，不够则不记答案往右二分，最大给1e9</p>
<p>邻接矩阵，邻接表</p>
<p>用矩阵直接表示图的关系</p>
<p><img src="https://com.miui.notes/note_image/f538f97f930dc2c67fd98427f7f48fdb9233db44"></p>
<p><img src="https://com.miui.notes/note_image/5157d9092912b259ac59a4581da45cf5211c645c"></p>
<p>归并排序 左程云</p>
<p><img src="https://com.miui.notes/note_image/599f6a619177654b23acb30d4b8fb7c2afb6a370"></p>
<p><img src="https://com.miui.notes/note_image/2b9211f8b55f5e9a1cdc95a6203e6c0102789076"></p>
<p>拆分原数组，分别排序，再merge归并。</p>
<p>欧拉函数</p>
<p>oi百科</p>
<p>kmp  左程云101</p>
<p>核心思想：利用已经匹配过的部分信息，避免不必要的字符比较，从而提高匹配效率。</p>
<p>next数组加速匹配    记录模式串中每个位置之前最长的相同前缀和后缀长度。以下是 next 数组的维护方法：</p>
<ol>
<li><p>初始化：设模式串为 p ，长度为 m 。 next[0] 通常初始化为 -1 ，这是一个特殊标记，表示已经到达模式串的开头。</p>
</li>
<li><p>计算过程：</p>
</li>
</ol>
<p>设两个指针 i 和 j ， i 从1开始遍历模式串， j 初始化为 next[0] 即 -1 。</p>
<p>当 i &lt; m 时，执行以下操作：</p>
<p>如果 j &#x3D;&#x3D; -1 或者 p[i] &#x3D;&#x3D; p[j + 1] ，则 i 和 j 都向前移动一位，并且 next[i] &#x3D; j + 1 。这意味着找到了更长的相同前缀和后缀。</p>
<p>否则， j 回溯到 next[j] ，即尝试找到次长的相同前缀和后缀，重复这个过程，直到 j &#x3D;&#x3D; -1 或者 p[i] &#x3D;&#x3D; p[j + 1] 。</p>
<p>例如，对于模式串 “ABABACA” ：</p>
<p>初始化 next[0] &#x3D; -1 。</p>
<p>当 i &#x3D; 1 时， j &#x3D; -1 ，此时 j &#x3D;&#x3D; -1 ，所以 next[1] &#x3D; 0 ， i 变为2， j 变为0。</p>
<p>当 i &#x3D; 2 时， p[2]!&#x3D; p[1] ， j 回溯到 next[0] &#x3D; -1 ，所以 next[2] &#x3D; 0 ， i 变为3， j 变为 - 1。</p>
<p>当 i &#x3D; 3 时， j &#x3D;&#x3D; -1 ，所以 next[3] &#x3D; 0 ， i 变为4， j 变为0。</p>
<p>当 i &#x3D; 4 时， p[4] &#x3D;&#x3D; p[1] ，所以 next[4] &#x3D; 1 ， i 变为5， j 变为1。</p>
<p>当 i &#x3D; 5 时， p[5]!&#x3D; p[2] ， j 回溯到 next[1] &#x3D; 0 ， p[5]!&#x3D; p[1] ， j 再回溯到 next[0] &#x3D; -1 ，所以 next[5] &#x3D; 0 ， i 变为6， j 变为 - 1。</p>
<p>当 i &#x3D; 6 时， j &#x3D;&#x3D; -1 ，所以 next[6] &#x3D; 0 。</p>
<p>最终得到 next 数组为 [-1, 0, 0, 0, 1, 0, 0] 。</p>
<p>通过维护 next 数组，KMP算法在匹配过程中能够快速地跳过一些不必要的比较，从而提高匹配效率。</p>
<p>最大公约数（Greatest Common Divisor，简称GCD）</p>
<p>long gcd(long a, long b) </p>
<p>{return b &#x3D;&#x3D; 0? a : gcd(b, a % b);}</p>
<p>这里使用了一个三元运算符（条件运算符）。它的含义是：如果  b  等于  0 ，那么返回  a ，因为当  b  为  0  时， a  就是这两个数的最大公约数。如果  b  不等于  0 ，则递归调用  gcd  函数，新的参数是  b  和  a  除以  b  的余数  a % b 。这是基于欧几里得算法（辗转相除法）来计算最大公约数的原理。</p>
<p>gcd证明</p>
<p><img src="https://com.miui.notes/note_image/30c18c7c47ad356c2e602f4c01ef32baecdacd3a"></p>
<p>lcm</p>
<p>long long lcm(long long a, long long b) </p>
<p>{return a &#x2F; gcd(a, b) * b; }</p>
<p>例(二分，gcd，lcm，同余)</p>
<p><img src="https://com.miui.notes/note_image/cf0e9244c93192630cf9fea31a7835a1f0a535df"></p>
<p>左程云041</p>
<p>f函数:1-x上有多少个数能被a，b整除?</p>
<p>x&#x2F;a+x&#x2F;b-x&#x2F;(a+b)  (容斥原理)</p>
<p><img src="https://com.miui.notes/note_image/046611c0bc1f1f95ad520311f9896b8b5682a69b"></p>
<p>同余原理 左程云041</p>
<p>加法乘法可以在每一步运算时取余，与仅在最后对得到的结果取余结果相同。</p>
<p>减法可能会得到负数，故+m后再模m。</p>
<p><img src="https://com.miui.notes/note_image/a43f7f8e4289bb715954f3b96ed19ee9697e3178"></p>
<p>离散化</p>
<p>048</p>
<p>将无限或大范围的数值映射到有限、连续的整数区间，保留相对大小关系，用于优化数据范围过大的问题（如坐标压缩、频率统计）。</p>
<p>&#x2F;&#x2F; 离散化单个值x（tmp为排序去重后的数组）</p>
<p>int idx &#x3D; lower_bound(tmp.begin(), tmp.end(), x) - tmp.begin();</p>
<p>lower_bound 返回第一个≥当前值的位置，保证相同值映射到同一下标</p>
<p>dfs深度优先搜索</p>
<p>一只会code的小金鱼</p>
<p>排列，指数级 深入探索分支至无法继续，然后回溯后探索其他分支。核心于递归</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47733361/article/details/123858318?sharetype=blog&shareId=123858318&sharerefer=APP&sharesource=2401_87034440&sharefrom=link">https://blog.csdn.net/qq_47733361/article/details/123858318?sharetype=blog&amp;shareId=123858318&amp;sharerefer=APP&amp;sharesource=2401_87034440&amp;sharefrom=link</a></p>
<p>DFS适合此类题目：给定初始状态跟目标状态，要求判断从初始状态到目标状态是否有解。</p>
<p>bfs</p>
<p>左程云062 </p>
<p>一只会code的小金鱼</p>
<p>队列，逐层扩散，扩散几层最短路就是多少，可以单点弹出，整层弹出。标记状态数组，剪枝。</p>
<p>板子</p>
<p><img src="https://com.miui.notes/note_image/a6c9993e274ca66013f4acdccd0d715df63e35c6"></p>
<p>使用要求，任意两相邻节点距离等同(边权相同)。</p>
<p>二段性 一边全符合，另一边全不符合，且队列内最多两种状态。x和x+1。</p>
<p>bfs队列具有的性质</p>
<p>单调性 单调增减</p>
<p>多源bfs，提前把源头存入队列(有个虚拟的源点连接多个边权为0的点(多个源头))。</p>
<p>01bfs 双端队列 队头入队or队尾入队</p>
<p><img src="https://com.miui.notes/note_image/8e56bb56286e291a80a36326a6ad4d1e3d238ffa"></p>
<p>双向bfs 维护两个队列，需要知道起点和终点位置，从起点和终点同时开始bfs，维护状态数组记录两个bfs到的状态，若碰上则证明可以从起点到终点。</p>
<p>dp动态规划</p>
<p>一只会code的小金鱼</p>
<p>给点一个问题，拆分为一个个子问题，直到子问题得到解决。保存子问题答案以减少重复计算。(记忆化搜索)再根据子问题答案反推，得到原问题解。</p>
<p>动态规划是递推的子集？</p>
<p>例题:跳台阶  一个楼梯n级台阶，每次走一或两级，问从0到n有多少种方案。</p>
<p>dfs  传n，n&#x3D;1return1     &#x3D;2return2   </p>
<p>else return dfsn-1   +  dfsn-2</p>
<p><img src="https://com.miui.notes/note_image/11fdc9ae2f763cd253fabe50e7fcb8465b64e1bc" alt="从第三级上一步到第四级or第二级上两步到  O(2的n次方)"></p>
<p>记忆化搜索(dfs+记录答案)想实现记忆化搜索，dfs的参数应该尽可能少，不应该传入不影响边界的参数。</p>
<p>剪枝则应该尽可能把能剪枝的参数传入保留</p>
<p><img src="https://com.miui.notes/note_image/a71d3e0c0a8e7998d661f9eeaaae4d92c61f47ff"></p>
<p>递归 递分解问题 自顶向下，归得到答案 自底向上。只进行归可不可以？从下逐层往上推</p>
<p>递推公式(dfs向下递归公式)</p>
<p><img src="https://com.miui.notes/note_image/2f609b35b6cff44abefea73250ec412b8a3f6a51" alt="只用三个变量即可，优化空间"></p>
<p>线性dp 例洛谷u224502</p>
<p>阿福是经验丰富大盗，要洗劫有N家店铺的一条街，每家店有现金。</p>
<p>已知同时洗劫相邻店铺报警系统会启动，阿福不想被抓，给定T组数据，每组数据先给店铺数N，再给N家店铺现金数，求每组数据下 阿福在不惊动警察时最多能得的现金数。</p>
<p><img src="https://com.miui.notes/note_image/6d16f20fdd2ff85e12c9b1086fbd5df75c6b6b55" alt="h数组存每家店有的现金数     f数组倒序计算出，从第i家店出发能得到的最多现金。(可以只用三个变量计算优化空间)"></p>
<p>普通堆实现的dijkstra算法</p>
<p><img src="https://com.miui.notes/note_image/2da67ebb7a358d166fd56f8069c2a0fcd8f0b113"></p>
<p><img src="https://com.miui.notes/note_image/d74abc9ceb5249fc043f1b486ec0bf03e3e9a1ae"></p>
<p>a*算法    问从特定点到特定点的最短距离</p>
<p>与dijkstra算法distance数组相同，区别在小根堆的使用时加一个曼哈顿距离(估计一个长度，影响小根堆弹出顺序，致使运行时间缩短)</p>
<p>Floyd算法    三层for循环 找从i到j点的距离和i到bridge点再从bridge到j点距离哪个更短，形成distance数组。</p>
<p><img src="https://com.miui.notes/note_image/8df9af822dd3f1bcdbdac6176ff7ef7ba4a69057"></p>
<p>关于 memset 和 0x3f</p>
<p>int a [100];</p>
<p>memset (a,0x3f,sizeof (a));</p>
<p>0x3f&#x3D;0011 1111&#x3D;63</p>
<p>C++ 中 int 型变量所占的位数为 4 个字节，即 32 位</p>
<p>0x3f 显然不是 int 型变量中单个字节的最大值，应该是 0x7f&#x3D;0111111111B</p>
<p>那为什么要赋值 0x3f??</p>
<ol>
<li>作为无穷大使用</li>
</ol>
<p>因为 4 个字节均为 0x3 时，0x3f3f3f3f3 的十进制是 1061109567, 也就就是 1e9 级别的</p>
<p>(和 0x7fffffff 一个数量级), 而一般场合下的数据都是小于 10^9 的，所以它可以作为无穷大使用。</p>
<ol start="2">
<li>可以保证无穷大加无穷大仍然不会超限。</li>
</ol>
<p>另一方面，由于一般的数据都不会大于 10^9, 所以当我们把无穷大加上一个数据时，</p>
<p>它并不会溢出 (这就满足了 “无穷大加一个有穷的数依然是无穷大”) 事实上</p>
<p>0x3f3f3f3f+0x3f3f3f3f&#x3D;2122219134, 这非常大但却没有超过 32-bit int_MAX 的表示</p>
<p>范围，所以 0x3f3f3f3f 还满足了我们 “无穷大加无穷大还是无穷大还是无穷大” 的需求。</p>
<p>void *memset (void *s, int ch, size_t n);</p>
<p>memset 是以字节为单位进行操作的。若用于初始化非字符类型的数组（像 int 数组），要确保你清楚每个字节被设置后对整个数据的影响。例如，若用 memset 把 int 数组初始化为 1，实际上每个字节都会被设为 1，而不是整个 int 值为 1。</p>
<p>在使用 memset 时，要保证传入的内存块指针 s 是有效的，并且 n 的值不会超出该内存块的边界，不然可能会引发未定义行为。</p>
<p>auto初始化定义变量</p>
<p>auto t &#x3D; q[hh]; 等于pair&lt;int, int&gt; t &#x3D; q[hh];</p>
<p>只用两个变量，交换其值</p>
<p>a，b  a&#x3D;a+b b&#x3D;a-b a&#x3D;a-b</p>
<p>*min_element(a, a+n)   a数组中从0到n-1最小元素  max同理</p>
<p>素数筛</p>
<p>思路 ：对于任意一个大于1  的正整数 ，那么它的 x倍就是合数（x&gt;1）。利用这个结论，我们可以避免很多次不必要的检测。</p>
<p>如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。</p>
<p><img src="https://com.miui.notes/note_image/d72c118cdd1fdf06b4588cbf73a8c9766a96f881"></p>
<p>快速幂</p>
<p>左程云098</p>
<p><img src="https://com.miui.notes/note_image/e616975f3024fdbf2cd124e5f3139938212b976e"></p>
<p>拆解幂次，举例10的75次方 75二进制为1001011</p>
<p>x&#x3D;x*方 即可得到二进制次方+1位。故仅需要10的64次方**10的8   <em>2</em>    *   1即为答案。</p>
<p>矩阵快速幂  同098</p>
<p>&#x2F;&#x2F; 矩阵乘法（支持模运算）</p>
<p>vector&lt;vector<int>&gt; multiply(const vector&lt;vector<int>&gt;&amp; a, const vector&lt;vector<int>&gt;&amp; b, int mod) {</p>
<pre><code>int n = a.size();

vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));

for (int i = 0; i &lt; n; ++i) &#123;

    for (int k = 0; k &lt; n; ++k) &#123;

        if (a[i][k] == 0) continue; // 优化：跳过0元素

        for (int j = 0; j &lt; n; ++j) &#123;

            res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % mod;

        &#125;

    &#125;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 矩阵快速幂（返回mat^power % mod）</p>
<p>vector&lt;vector<int>&gt; matrix_pow(vector&lt;vector<int>&gt; mat, int power, int mod) {</p>
<pre><code>int n = mat.size();

// 初始化单位矩阵

vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));

for (int i = 0; i &lt; n; ++i) res[i][i] = 1;

while (power &gt; 0) &#123;

    if (power % 2 == 1) res = multiply(res, mat, mod);

    mat = multiply(mat, mat, mod);

    power /= 2;

&#125;

return res;
</code></pre>
<p>}</p>
<p>并查集</p>
<p>蓝不过海呀</p>
<p>麦克老师讲算法</p>
<p>合并 查询 集合</p>
<p>用数组 保存每个节点的父亲</p>
<p>查询</p>
<p><img src="https://com.miui.notes/note_image/39568e40a1e7a7ba4bf837404646e46d47ab458b"></p>
<p><img src="https://com.miui.notes/note_image/07979f00208bea714b698dbfffdf3653c07ed159"></p>
<p>合并(按大小or高度合并  按秩合并)</p>
<p>矮树合并到高数不改变高度，高度一样则合并后高度+1  用h数组记录高度</p>
<p><img src="https://com.miui.notes/note_image/11fd842b83f1674e81781059c9f75fc29ba2105e"></p>
<p><img src="https://com.miui.notes/note_image/6ef94e5aab0f41843f99c62f4ba04c8aee199b4a"></p>
<p>不使用数组储存</p>
<p><img src="https://com.miui.notes/note_image/ba910341123cacdb2814ea2181ce7aaa22a4096c"></p>
<p>堆</p>
<p>大根堆小根堆，完全二叉树，根节点的值大于或小于其所有的子节点</p>
<p>priority_queue&lt;int, vector<int>, greater<int>&gt; min_heap; &#x2F;&#x2F; 小根堆，没有greater为大根堆 </p>
<p>优先队列</p>
<p>桶排序 基数排序计数排序(不基于比较，对于对象的数据特征有要求)</p>
<p>左程云028基数排序</p>
<p>计数排序</p>
<p>已知数值范围对每个数值计数，然后还原数组。</p>
<p><img src="https://com.miui.notes/note_image/91a447ae685ccc9c0c00d085927237605270b36f"></p>
<p>基数排序(一般要求为十进制非负整数)</p>
<p>判断最大的位数是几位，对每一位进行桶排序。</p>
<p>从个位开始，数组按个位数字大小入桶，然后从0-9倒出，此后十位百位同上循环，最终结果即有序。从低位开始作用为保留低位大小关系。</p>
<p>技巧1 前缀分区做桶排列</p>
<p><img src="https://com.miui.notes/note_image/a31fe0ce9e307e59a0b0537fc47b56d3655837ae"></p>
<p>统计每个数字出现次数后做前缀和得到数组(x)，则从右向左遍历原数组时，该数字在保留相对次序情况下应该出现在x数组对应的数字-1的位置，做完此操作后x数组对应数字–。</p>
<p>故该技巧可以用于基数排序时对每一位数字进行排序任务。</p>
<p>技巧2 怎么得到每一位</p>
<p>用一个变量offset初始化为1，所求数字n。(n&#x2F;offset)%10该位数操作玩后offset*&#x3D;10依次得到每一位数字。</p>
<p>最终code</p>
<p><img src="https://com.miui.notes/note_image/c1eba5d2703a175dfe042893edbfb00f018a86f0"></p>
<p>切比雪夫距离</p>
<p>切比雪夫距离（Chebyshev distance）是向量空间中的一种度量，二个点之间的距离定义为其各坐标数值差的最大值。</p>
<p>曼哈顿距离转换成切比雪夫距离</p>
<p>那么辐射范围变成了一个矩形</p>
<p>可以用O(n²)扫描线，扫描圆形辐射范围</p>
<p><img src="https://com.miui.notes/note_image/4f5db2a2f636335b036d3138f4d551fe51255bac"></p>
<p>位图</p>
<p>用bit组成数组存放值，用bit01代表存在与否，取存用位运算。</p>
<p>限制 必须连续范围，不能过大。</p>
<p>优点 极大的节省空间</p>
<p>～(取反)</p>
<p><img src="https://com.miui.notes/note_image/b556939c7b1ca94f44d501d53eeed2af3bf33c16"></p>
<p>如果使用时数组会越界一定要开大一点且每次初始化</p>
<p>st表</p>
<p>算法117 oi维基百科</p>
<p>博弈问题</p>
<p><img src="https://com.miui.notes/note_image/b2fba7854d935f9c4215229866c29a58f8f2c948"></p>
<p>lambda表达式(λ)</p>
<p><img src="https://com.miui.notes/note_image/2db9756d7b7d23dca1aaa7fbb1becc40767c47bf"></p>
<p><img src="https://com.miui.notes/note_image/e6f2556d0d79e62bad93fbc8a276d61bdb70100b"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>mohan</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2025/07/07/algorithm/">http://example.com/2025/07/07/algorithm/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2025/07/06/hello-world/">Hello World</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© mohan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>